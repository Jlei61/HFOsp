# HFOsp å¼€å‘è®¡åˆ’

**é¡¹ç›®ç›®æ ‡**: å¤ç°å¹¶æ‰©å±• HFO (é«˜é¢‘æŒ¯è¡) åˆ†ææµç¨‹ï¼ŒéªŒè¯ Source-Sink ç†è®º  
**æ•°æ®é›†**: ç‰æ³‰24å°æ—¶SEEGæ•°æ®é›†  
**æ•°æ®è·¯å¾„**: `/mnt/yuquan_data/yuquan_24h_edf`  
**æ›´æ–°æ—¥æœŸ**: 2026-01-16

---

## 0. æ ¸å¿ƒæ¶æ„åŸåˆ™

### æ•°æ®æµè®¾è®¡å“²å­¦

> "Bad programmers worry about the code. Good programmers worry about data structures." â€” Linus Torvalds

**å•ä¸€èŒè´£åŸåˆ™**ï¼šæ¯ä¸ªæ¨¡å—åªåšä¸€ä»¶äº‹å¹¶åšå¥½ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              HFOsp æ•°æ®æµæ¶æ„                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  [åŸå§‹EDF]                                                                      â”‚
â”‚      â”‚                                                                          â”‚
â”‚      â–¼                                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                            â”‚
â”‚  â”‚ preprocessing   â”‚ â”€â”€â†’ é¢„å¤„ç†ï¼šé‡å‚è€ƒã€æ»¤æ³¢ã€é€šé“é€‰æ‹©                          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                            â”‚
â”‚           â”‚ (data, sfreq, ch_names)                                             â”‚
â”‚           â–¼                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                            â”‚
â”‚  â”‚  hfo_detector   â”‚ â”€â”€â†’ HFOæ£€æµ‹ï¼šå•é€šé“äº‹ä»¶åˆ—è¡¨                                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                            â”‚
â”‚           â”‚ Dict[ch_name â†’ [(start, end), ...]]                                 â”‚
â”‚           â–¼                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚  â”‚           group_event_analysis                       â”‚                       â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚                        â”‚
â”‚  â”‚  â”‚ Step 1: ç¾¤ä½“äº‹ä»¶çª—å£æ„å»º                      â”‚    â”‚                       â”‚
â”‚  â”‚  â”‚   - build_windows_from_detections           â”‚    â”‚                        â”‚
â”‚  â”‚  â”‚   - è¾“å‡º: EventWindow list                   â”‚    â”‚                       â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚                        â”‚
â”‚  â”‚                     â–¼                               â”‚                        â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚                        â”‚
â”‚  â”‚  â”‚ Step 2: é¢„è®¡ç®— Envelope ç¼“å­˜ï¼ˆbandpasså¯é€‰ï¼‰   â”‚    â”‚                       â”‚
â”‚  â”‚  â”‚   - precompute_envelope_cache               â”‚    â”‚                        â”‚
â”‚  â”‚  â”‚   - å­˜å‚¨: *_envCache.npz                    â”‚    â”‚                        â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚                        â”‚
â”‚  â”‚                     â–¼                               â”‚                        â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚                        â”‚
â”‚  â”‚  â”‚ Step 3: è´¨å¿ƒåˆ†æï¼ˆTFå¯é€‰ï¼‰â†’ å­˜å‚¨ä¸­é—´ç»“æœ       â”‚    â”‚                       â”‚
â”‚  â”‚  â”‚   - compute_group_analysis_results          â”‚    â”‚                        â”‚
â”‚  â”‚  â”‚   - å­˜å‚¨: *_groupAnalysis.npz               â”‚    â”‚ â† å…³é”®æ–°å¢ï¼           â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚                        â”‚
â”‚  â”‚                     â”‚                               â”‚                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                        â”‚                                                        â”‚
â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                           â”‚
â”‚           â–¼                         â–¼                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                   â”‚
â”‚  â”‚ network_analysisâ”‚      â”‚  visualization  â”‚ â† åªè¯»å–ä¸­é—´ç»“æœï¼Œä¸åšè®¡ç®—ï¼       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   â”‚
â”‚                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ä¸­é—´ç»“æœå­˜å‚¨è§„èŒƒ

**å­˜å‚¨ä½ç½®**: `/mnt/yuquan_data/yuquan_24h_edf/<patient>/`ï¼ˆä¸EDFåŒç›®å½•ï¼‰

| æ–‡ä»¶åæ¨¡å¼ | å†…å®¹ | æ¥æºæ¨¡å— |
|-----------|------|----------|
| `*_gpu.npz` | å†å²GPUæ£€æµ‹ç»“æœ | (å·²æœ‰) |
| `*_packedTimes.npy` | äº‹ä»¶çª—å£ | (å·²æœ‰) |
| `*_lagPat*.npz` | å†å²lagçŸ©é˜µ | (å·²æœ‰) |
| `*_envCache_{band}_{ref}.npz` | **Envelopeç¼“å­˜ï¼ˆx_bandå¯é€‰ï¼‰** | `group_event_analysis` |
| `*_groupAnalysis.npz` | **è´¨å¿ƒ+lagï¼ˆTFå¯é€‰ï¼‰åˆ†æç»“æœ** | `group_event_analysis` |

### `*_groupAnalysis.npz` ç»“æ„ï¼ˆæ ¸å¿ƒæ–°å¢ï¼‰

```python
{
    # === å…ƒæ•°æ® ===
    'sfreq': np.array([2000.0]),           # é‡‡æ ·ç‡
    'band': np.array(['ripple']),          # é¢‘æ®µ
    'ch_names': np.array([...]),           # æ ¸å¿ƒé€šé“å (n_ch,)
    'window_sec': np.array([0.5]),         # çª—å£é•¿åº¦
    'n_events': np.array([2601]),          # äº‹ä»¶æ•°
    'n_channels': np.array([8]),           # é€šé“æ•°
    
    # === äº‹ä»¶çª—å£ ===
    'event_windows': np.array([...]),      # (n_events, 2) [start, end] ç§’
    
    # === è´¨å¿ƒåˆ†æ ===
    'centroid_time': np.array([...]),      # (n_ch, n_events) æ—¶é—´è´¨å¿ƒ(ç›¸å¯¹çª—å£èµ·å§‹, é»˜è®¤env)
    'tf_centroid_time': np.array([...]),   # (n_ch, n_events) TFè´¨å¿ƒæ—¶é—´åˆ†é‡ï¼ˆå¯é€‰ï¼‰
    'tf_centroid_freq': np.array([...]),   # (n_ch, n_events) TFè´¨å¿ƒé¢‘ç‡åˆ†é‡ï¼ˆå¯é€‰ï¼‰
    'events_bool': np.array([...]),        # (n_ch, n_events) é€šé“æ˜¯å¦å‚ä¸
    
    # === Lag/Rank åˆ†æ ===
    'lag_raw': np.array([...]),            # (n_ch, n_events) ç›¸å¯¹lag(å¯¹é½åˆ°æœ€æ—©é€šé“)
    'lag_rank': np.array([...]),           # (n_ch, n_events) æ’å (0=æœ€æ—©)

    # === Co-activation (ch Ã— ch) ===
    'coact_event_count': np.array([...]),  # (n_ch, n_ch) å…±åŒæ¿€æ´»äº‹ä»¶æ•°
    'coact_event_ratio': np.array([...]),  # (n_ch, n_ch) å…±åŒæ¿€æ´»æ¯”ä¾‹ (=count/n_events)
    'coact_time_ratio': np.array([...]),   # (n_ch, n_ch) è´¨å¿ƒç»å¯¹æ—¶é—´å¯¹é½å¼ºåº¦(0..1)
    'coact_rank_ratio': np.array([...]),   # (n_ch, n_ch) è´¨å¿ƒç›¸å¯¹rankå¯¹é½å¼ºåº¦(0..1)
    
    # === å¯é€‰ï¼šTF å˜æ¢ç»“æœ (ç”¨äºé«˜çº§å¯è§†åŒ–) ===
    'tf_power_per_event': np.array([...]), # (n_ch, n_events, n_freq, n_time) å¯é€‰
}
```

### Visualization èŒè´£è¾¹ç•Œï¼ˆé“å¾‹ï¼‰

**visualization.py åªè´Ÿè´£**ï¼š
1. è¯»å– `*_groupAnalysis.npz` æˆ– `*_envCache.npz`
2. æ ¹æ®å‚æ•°é€‰æ‹©å­é›†ï¼ˆé€šé“ã€äº‹ä»¶ï¼‰
3. è°ƒç”¨ matplotlib ç”»å›¾

**visualization.py ç¦æ­¢**ï¼š
- âŒ è®¡ç®— STFT
- âŒ è®¡ç®—è´¨å¿ƒ
- âŒ è®¡ç®— Hilbert envelope
- âŒ ä»»ä½•è¶…è¿‡ 100 è¡Œçš„æ•°æ®å¤„ç†

---

## 1. æ•°æ®é›†æ¦‚è§ˆ

| æŒ‡æ ‡ | æ•°å€¼ |
|------|------|
| æ‚£è€…æ•°é‡ | 21äºº (14äººå·²å¤„ç†) |
| EDFæ–‡ä»¶ | 260ä¸ª (çº¦520å°æ—¶) |
| é‡‡æ ·ç‡ | 2000 Hz |
| å•æ–‡ä»¶æ—¶é•¿ | çº¦2å°æ—¶ |
| é€šé“æ•° | 145 (åŸå§‹, å«éSEEG) â†’ ~140 (SEEG) â†’ ~130 (Bipolarå‚è€ƒåå¯¹) â†’ 8 (æ ¸å¿ƒ, lagPat) |
| HFOäº‹ä»¶ | ~170ä¸‡+ |

**å·²æœ‰ä¸­é—´ç»“æœ**:
- `*_gpu.npz`: 120é€šé“ Ã— å˜é•¿äº‹ä»¶åˆ—è¡¨
- `*_lagPat.npz`: 8é€šé“ Ã— 2601äº‹ä»¶ æ»åçŸ©é˜µ  
- `*_packedTimes.npy`: äº‹ä»¶æ—¶é—´çª— [start, end]
- `hist_meanX.npz`: æ ¸å¿ƒé€šé“ç­›é€‰ç»“æœ

---

## 2. ç°æœ‰æ–‡ä»¶ç»“æ„

```
HFOsp/
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ DEVELOP_PLAN.md          # æœ¬æ–‡ä»¶
â”‚   â”œâ”€â”€ README_YUQUAN.md         # æ•°æ®é›†ä½¿ç”¨è¯´æ˜
â”‚   â””â”€â”€ yuquan_24h_dataset_structure.md  # æ•°æ®ç»“æ„è¯¦è§£
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py              # âœ… æ¨¡å—å¯¼å‡º
â”‚   â”œâ”€â”€ preprocessing.py         # âœ… é¢„å¤„ç†Pipeline
â”‚   â”œâ”€â”€ hfo_detector.py          # âœ… HFOæ£€æµ‹å™¨
â”‚   â”œâ”€â”€ group_event_analysis.py  # âœ… ç¾¤ä½“äº‹ä»¶åˆ†æï¼ˆæ ¸å¿ƒè®¡ç®—ä¸­å¿ƒï¼‰
â”‚   â”œâ”€â”€ network_analysis.py      # [å¾…å¼€å‘] ç½‘ç»œåˆ†æ
â”‚   â”œâ”€â”€ visualization.py         # âš ï¸ å¯è§†åŒ–ï¼ˆéœ€é‡æ„ï¼šå‰¥ç¦»è®¡ç®—é€»è¾‘ï¼‰
â”‚   â””â”€â”€ utils/
â”‚       â””â”€â”€ bqk_utils.py         # åŸºç¡€å·¥å…·å‡½æ•°
â”œâ”€â”€ datasets/
â”‚   â”œâ”€â”€ quick_view_yuquan.py     # æ•°æ®å¿«é€ŸæŸ¥çœ‹
â”‚   â””â”€â”€ ...
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ visualize_event_waveforms.py
â”‚   â””â”€â”€ yuquan_analysis.py
â”œâ”€â”€ notebook/
â”‚   â””â”€â”€ chengshuai_hfo_analysis.ipynb  # âœ… ç¤ºä¾‹notebook
â”œâ”€â”€ yuquan_dataloader.py         # æ•°æ®åŠ è½½å™¨
â””â”€â”€ requirements.txt             # [å¾…åˆ›å»º]
```

---

## 3. æ ¸å¿ƒæ•°æ®æµ

```
åŸå§‹EDF (145é€šé“, 2000Hz, 2h) 
    â”‚
    â”œâ”€ ç”µæåç§°è§£æ (å»POL/EEGå‰ç¼€, æ’é™¤EMG/ECG)
    â”‚
    â”œâ”€ Bipolaré‡å‚è€ƒ (åŒç”µæä¸²ç›¸é‚»è§¦ç‚¹å·®åˆ†)
    â”‚   â””â”€ ä¸¥æ ¼è§„åˆ™: ä»…åŒå‰ç¼€ + æ•°å­—è¿ç»­/ç›¸é‚»
    â”‚   â””â”€ 145 â†’ çº¦120é€šé“
    â”‚
    â”œâ”€ é‡é‡‡æ · (Ripple: 1000Hz, FR: ä¿ç•™2000Hz)
    â”‚
    â”œâ”€ æ»¤æ³¢ (Notch 50Hzè°æ³¢ + Bandpass)
    â”‚
    â””â”€ é€šé“è´¨é‡æ£€æŸ¥ (z-scoreå¼‚å¸¸, æ–¹å·®æ£€æµ‹)
         â”‚
         â–¼
    æ»¤æ³¢åæ•°æ® (120é€šé“, 1000/2000Hz)
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚         â”‚
  Ripple    Fast-Ripple
 80-250Hz   250-500Hz
    â”‚         â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚
    HFOäº‹ä»¶æ£€æµ‹ (HilbertåŒ…ç»œ + åŒé˜ˆå€¼)
         â”‚
         â”œâ”€ Ictalæ®µè½æ£€æµ‹ (èƒ½é‡çˆ†å‘ + æŒç»­>3s)
         â”œâ”€ èƒŒæ™¯åŸºçº¿ä¼°è®¡ (å‰”é™¤Ictalåè®¡ç®—)
         â””â”€ åˆ†æ®µè‡ªé€‚åº”é˜ˆå€¼
         â”‚
         â–¼
    å•é€šé“HFOäº‹ä»¶åˆ—è¡¨
         â”‚
    ç¾¤ä½“äº‹ä»¶è¯†åˆ« (500msçª—å£å†…å¤šé€šé“å…±ç°)
         â”‚
         â”œâ”€ æ»åè®¡ç®— (HilbertåŒ…ç»œäº’ç›¸å…³)
         â”œâ”€ æ ¸å¿ƒé€šé“ç­›é€‰ (å¯†åº¦/Out-Strength/é¦–å‘)
         â””â”€ é¢‘ç‡ä¸­å¿ƒè®¡ç®—
         â”‚
         â–¼
    æ»åçŸ©é˜µ (8æ ¸å¿ƒé€šé“ Ã— Näº‹ä»¶)
         â”‚
    æœ‰å‘ç½‘ç»œæ„å»º
         â”‚
         â”œâ”€ å®¹ç§¯ä¼ å¯¼å‰”é™¤ (è·ç¦»+æ»åæ¡ä»¶)
         â”œâ”€ Interictal/Ictal åˆ†æ®µç½‘ç»œ
         â””â”€ å›¾è®ºæŒ‡æ ‡è®¡ç®—
         â”‚
         â–¼
    Source-Sink éªŒè¯
```

---

## 4. æ¨¡å—å¼€å‘è®¡åˆ’

### æ¨¡å—1: src/preprocessing.py âœ… å®Œæˆï¼ˆPhase 1 é‡æ„ 2026-01-30ï¼‰

| åŠŸèƒ½ | è¯´æ˜ | çŠ¶æ€ |
|------|------|------|
| 1.1 EDFè¯»å– | åŠ è½½EDF, æ¸…æ´—ç”µæåç§°, encoding='latin1' | âœ… |
| 1.2 ç”µæåç§°è§£æ | æ­£åˆ™æå– (prefix, number), æ”¯æŒA'5æ ¼å¼ | âœ… |
| 1.3 é‡å‚è€ƒç­–ç•¥ | **æ˜¾å¼** bipolar / car / noneï¼ˆauto=å…¼å®¹åˆ«åâ†’bipolarï¼›ä¸åšä»»ä½•"æ¨æ–­"ï¼‰ | âœ… |
| 1.4 é€šé“é€‰æ‹© | **æ˜¾å¼** include/exclude channelsï¼ˆç”¨äºå¤ç°GPUé€šé“åˆ—è¡¨ï¼›ä¸ç¡¬ç¼–ç "å»æ‰æœ«ç«¯Nä¸ªè§¦ç‚¹"ï¼‰ | âœ… |
| 1.5 é‡é‡‡æ · | Rippleâ†’1000Hz, FRâ†’2000Hz | âœ… |
| 1.6 æ»¤æ³¢ | Notch + å¯é€‰Bandpass, GPUåŠ é€Ÿæ”¯æŒ | âœ… |
| 1.7 é€šé“è´¨é‡æ£€æŸ¥ | z-score, æ–¹å·®, ä¼ªè¿¹æ ‡è®° | âœ… |
| **1.8 FilterBackendæ¶æ„** | **æŠ½è±¡æ¥å£ + CPU/GPUå®ç°åˆ†ç¦»** | âœ… **NEW** |

#### Phase 1 é‡æ„æ€»ç»“ï¼ˆ2026-01-30ï¼‰

**æ ¸å¿ƒæ”¹è¿›ï¼šæ¶ˆé™¤é‡å¤çš„æ¡ä»¶åˆ¤æ–­**

```python
# Before: æ•£è½å„å¤„çš„ GPU åˆ¤æ–­
if self.use_gpu and HAS_GPU:
    return self._apply_filters_gpu(...)  # 70+ lines
else:
    return self._apply_filters_cpu(...)  # 30+ lines

# After: åˆå§‹åŒ–æ—¶å†³å®šåç«¯ï¼Œè¿è¡Œæ—¶é›¶åˆ¤æ–­
self.filter_backend = GpuFilterBackend() if use_gpu else CpuFilterBackend()

def _apply_filters(self, data, sfreq):
    if self.notch_freqs:
        data = self.filter_backend.apply_notch(data, sfreq, self.notch_freqs)
    if self.bandpass:
        data = self.filter_backend.apply_bandpass(data, sfreq, *self.bandpass)
    return data
```

**åˆ é™¤çš„åºŸä»£ç **ï¼ˆé›¶ç ´åæ€§ï¼‰ï¼š
- âŒ `PreBipolarDetector` (15è¡Œ) - ç©ºå£³ç±»ï¼Œæ€»æ˜¯è¿”å› False
- âŒ `validate_against_gpu_results()` (12è¡Œ) - è¿è¡Œæ—¶æŠ›å¼‚å¸¸çš„åºŸå‡½æ•°
- âŒ `exclude_last_n` å‚æ•° - ä»æ‰€æœ‰ç±»å’Œå‡½æ•°ç­¾åä¸­ç§»é™¤

**æ–°å¢çš„æ¶æ„ç»„ä»¶**ï¼š

```python
# æŠ½è±¡æ¥å£
class FilterBackend:
    def apply_notch(data, sfreq, freqs): ...
    def apply_bandpass(data, sfreq, low, high): ...

# CPU å®ç°ï¼ˆscipy filtfiltï¼‰
class CpuFilterBackend(FilterBackend): ...

# GPU å®ç°ï¼ˆCuPy + chunked processingï¼‰
class GpuFilterBackend(FilterBackend):
    def __init__(self, chunk_sec=20.0): ...
    # è‡ªåŠ¨å¤„ç† GPU OOM - 20s chunks + reflect padding
```

**æ‰©å±•æ–°åç«¯çš„æ–¹æ³•**ï¼š

```python
# ä¾‹å¦‚ï¼šæ·»åŠ  Apple Metal æ”¯æŒ
class MetalFilterBackend(FilterBackend):
    def apply_notch(self, data, sfreq, freqs):
        # ä½¿ç”¨ PyTorch MPS æˆ– Metal Performance Shaders
        ...
    
    def apply_bandpass(self, data, sfreq, low, high):
        ...

# ä½¿ç”¨ï¼š
preprocessor = SEEGPreprocessor(
    use_gpu=False,  # ä¸ä½¿ç”¨ CUDA
    # æ‰‹åŠ¨æ›¿æ¢ backendï¼ˆé«˜çº§ç”¨æ³•ï¼‰
)
preprocessor.filter_backend = MetalFilterBackend()
```

**æ”¶ç›Š**ï¼š
- âœ… ä»£ç è¡Œæ•°: 1223 â†’ 1199 (-24è¡Œï¼Œè´¨é‡æå‡æ˜¾è‘—)
- âœ… GPU æ¡ä»¶åˆ†æ”¯: 4å¤„ â†’ 0å¤„
- âœ… å¯æ‰©å±•æ€§: æ·»åŠ æ–° backend (Metal/ROCm/OpenCL) åªéœ€å®ç° 2 ä¸ªæ–¹æ³•
- âœ… å¯æµ‹è¯•æ€§: æ¯ä¸ª backend å¯ç‹¬ç«‹å•å…ƒæµ‹è¯•
- âœ… é›¶ç ´åæ€§: æ‰€æœ‰å¤–éƒ¨è°ƒç”¨æ¥å£ä¿æŒå‘åå…¼å®¹

---

#### å…³é”®æŠ€æœ¯å†³ç­–ï¼ˆå†å²è®°å½•ï¼‰

- **ä¸å†çŒœ**ï¼šä¸å†æ ¹æ®"æŸäº›contactç¼ºå¤±"å»æ¨æ–­EDFæ˜¯å¦å·²åšbipolarï¼›é‚£æ˜¯é€šé“é€‰æ‹©ç­–ç•¥ï¼Œä¸æ˜¯é‡å‚è€ƒè¯æ®ã€‚
- **é‡å‚è€ƒç­–ç•¥ï¼ˆæ˜¾å¼ï¼‰**:
  - `'bipolar'`: åŒshaftç›¸é‚»è§¦ç‚¹å·®åˆ†ï¼›**å‘½åä¸ºæ˜ç¡®çš„`A1-A2`**ï¼Œé¿å…ä¸å•æé€šé“æ··æ·†
  - `'car'`: æ¯ä¸ªshaftå†…éƒ¨åšCAR
  - `'none'`: ä¿æŒEDFåŸå§‹å‚è€ƒï¼ˆå•æ/å‚è€ƒç”µæä½“ç³»ï¼‰ï¼Œä¸åšä»»ä½•æ¨æ–­
- **GPUé€šé“å·®å¼‚æ¥æºï¼ˆå·²ç¡®è®¤ï¼Œchengshuai/FC10477Qï¼‰**ï¼š
  - `*_gpu.npz` çš„ `chns_names` æ˜¯ EDF æ¸…æ´—åé€šé“çš„å­é›†ï¼›
  - å·®å¼‚ä¸»è¦æ¥è‡ª**é€šé“é€‰æ‹©/å‰”é™¤ç­–ç•¥**ï¼ˆä¾‹å¦‚æ¯ä¸ªshaftç¼ºå°‘æœ«ç«¯è‹¥å¹²contactï¼‰ï¼Œå¹¶ébipolaræ¨æ–­ä¾æ®ï¼›
  - è‹¥è¦å¤ç°GPUé€šé“é›†åˆï¼Œä½¿ç”¨ `include_channels=gpu['chns_names']`ï¼ˆæ˜¾å¼ï¼‰ã€‚

---

### æ¨¡å—2: src/hfo_detector.py âœ… å®Œæˆï¼ˆPhase 2 é‡æ„ 2026-01-31ï¼‰

| åŠŸèƒ½ | è¯´æ˜ | çŠ¶æ€ |
|------|------|------|
| 2.1 çº¯BQKç®—æ³• | åˆ é™¤ `mad_hysteresis` ç®—æ³•ï¼ˆ-200è¡Œä»£ç ï¼‰ | âœ… |
| 2.2 BQKDetectorç±» | å°è£… `bqk_utils.py`ï¼Œé¢„è®¡ç®—æ»¤æ³¢å™¨ç³»æ•° | âœ… |
| 2.3 å¤šå¸¦åŒ…ç»œ | å®½å¸¦åˆ†20Hzå­å¸¦ï¼ŒButterworth 3é˜¶æ»¤æ³¢ + Hilbert | âœ… |
| 2.4 å¹¶è¡ŒåŒ– | `joblib.Parallel` å¹¶è¡Œè®¡ç®—å­å¸¦åŒ…ç»œ | âœ… |
| 2.5 åŒé˜ˆå€¼æ£€æµ‹ | `rel_threshÃ—local_median` âˆ§ `abs_threshÃ—global_median` | âœ… |
| 2.6 äº‹ä»¶åˆå¹¶ç­›é€‰ | `merge_timeRanges` + `min_last` æŒç»­æ—¶é—´è¿‡æ»¤ | âœ… |
| 2.7 Ripple/FRåˆ†ç¦» | `band='ripple'/'fast_ripple'` | âœ… |

#### Phase 2 é‡æ„æ€»ç»“ï¼ˆ2026-01-31ï¼‰

**æ ¸å¿ƒæ”¹è¿›ï¼šå°è£… + å¹¶è¡ŒåŒ–ï¼ˆä½†æ³¨æ„é€‚ç”¨åœºæ™¯ï¼‰**

```python
# Before: åˆ†æ•£çš„å‡½æ•°è°ƒç”¨
env = bqk.return_hil_enve_norm(data, fs, freqband)  # å†…éƒ¨å¾ªç¯Kæ¬¡æ»¤æ³¢
events = bqk.find_high_enveTimes(env, ...)

# After: æ¸…æ™°çš„ç±»å°è£… + å¯é€‰å¹¶è¡Œ
detector = BQKDetector(sfreq=fs, freqband=(80,250), n_jobs=1)  # é»˜è®¤ä¸²è¡Œ
env = detector.compute_envelope(data)  # é¢„è®¡ç®—æ»¤æ³¢å™¨ç³»æ•°
events = detector.detect_events(data)  # ç«¯åˆ°ç«¯æ£€æµ‹
```

**åˆ é™¤çš„ä»£ç **ï¼ˆé›¶ç ´åæ€§ï¼Œ-348è¡Œï¼‰ï¼š
- âŒ `mad_hysteresis` ç®—æ³•åŠæ‰€æœ‰ç›¸å…³å‡½æ•°ï¼ˆ~200è¡Œï¼‰
- âŒ GPUç›¸å…³ä»£ç ï¼ˆ`cupy_hilbert`, `_HAS_CUPY`ï¼‰
- âŒ Ictalæ£€æµ‹ç›¸å…³ï¼ˆ`_detect_ictal_mask`, `_mad`, `_moving_average`, `_find_runs`ï¼‰

**æ€§èƒ½æµ‹è¯•ç»“æœ**ï¼ˆ2026-01-31, cuda_envï¼‰ï¼š

| åœºæ™¯ | n_jobs=1 | n_jobs=-1 | ç»“è®º |
|------|----------|-----------|------|
| å°æ•°æ® (8chÃ—10s) | 0.078s | 0.902s | âŒ å¹¶è¡Œæ…¢12x (è¿›ç¨‹å¼€é”€) |
| å¤§æ•°æ® (16chÃ—30s) | 0.457s | 1.100s | âŒ å¹¶è¡Œæ…¢2.4x |
| æ•°å€¼ä¸€è‡´æ€§ | - | diff=1.81e-10 | âœ… å®Œç¾ |

**å…³é”®å‘ç°ï¼ˆAmdahl's Lawé™·é˜±ï¼‰**ï¼š
```
å¹¶è¡Œå¼€é”€ = joblibè¿›ç¨‹åˆ›å»º (~500ms) + æ•°æ®åºåˆ—åŒ– (~200ms)
è®¡ç®—æ—¶é—´ = K Ã— (æ»¤æ³¢+Hilbert) â‰ˆ 0.078s (K=9, 8chÃ—10s)

å½“ è®¡ç®—æ—¶é—´ < å¹¶è¡Œå¼€é”€ â†’ ä¸²è¡Œæ›´å¿«
```

**å¹¶è¡ŒåŒ–é€‚ç”¨åœºæ™¯**ï¼š
- âœ… **é•¿æ—¶ç¨‹æ— chunk**ï¼š`chunk_sec=None` + å•æ–‡ä»¶>2åˆ†é’Ÿ + K>20
- âŒ **é»˜è®¤chunkedå¤„ç†**ï¼š30s chunk â†’ è®¡ç®— <200ms â†’ n_jobs=1 æ›´å¿«

**æ¨èé…ç½®**ï¼š

```python
# é»˜è®¤é…ç½®ï¼ˆæ¨èï¼‰ï¼šn_jobs=1
config = HFODetectionConfig(
    band='ripple',
    chunk_sec=30.0,  # åˆ†å—å¤„ç†
    n_jobs=1,        # â† ä¸²è¡Œé¿å…è¿›ç¨‹å¼€é”€
)

# å…¨æ–‡ä»¶å¤„ç†ï¼ˆç‰¹æ®Šåœºæ™¯ï¼‰ï¼š
config = HFODetectionConfig(
    chunk_sec=None,  # â† æ•´ä¸ªæ–‡ä»¶ä¸€æ¬¡æ€§å¤„ç†
    n_jobs=-1,       # â† å¯èƒ½æœ‰æ”¶ç›Šï¼ˆéœ€æµ‹è¯•ï¼‰
)
```

**æ”¶ç›Š**ï¼š
- âœ… ä»£ç : 632è¡Œ â†’ 284è¡Œ (-55%)
- âœ… ç®—æ³•: å•ä¸€BQKè·¯å¾„
- âœ… å°è£…: `BQKDetector` ç±»ï¼Œæ»¤æ³¢å™¨ç³»æ•°é¢„è®¡ç®—
- âœ… æ•°å€¼: ä¸åŸ `bqk_utils.py` è¯¯å·® <1e-9
- âš ï¸ å¹¶è¡Œ: **ä»…é•¿æ—¶ç¨‹åœºæ™¯æœ‰æ•ˆï¼Œé»˜è®¤åœºæ™¯åè€Œå˜æ…¢**

**å…³é”®æŠ€æœ¯å†³ç­–**:
- **ç®—æ³•çº¯åŒ–**: åªä¿ç•™BQKï¼Œåˆ é™¤æ‰€æœ‰éBQKä»£ç 
- **ç±»å°è£…**: `BQKDetector` é¢„è®¡ç®—æ»¤æ³¢å™¨ç³»æ•°ï¼ˆä¸å†æ¯chunké‡å¤ï¼‰
- **Chunkedå¤„ç†**: 30s chunk + 1s overlapï¼Œé¿å…å†…å­˜çˆ†ç‚¸
- **å¹¶è¡ŒåŒ–ç­–ç•¥**: é»˜è®¤ `n_jobs=1`ï¼ˆå®æµ‹æ›´å¿«ï¼‰ï¼Œé¿å…joblibå¼€é”€
- **åŒé˜ˆå€¼ç­–ç•¥**: `rel_thresh Ã— local_median` âˆ§ `abs_thresh Ã— global_median`

---

### æ¨¡å—3: src/group_event_analysis.py âœ… æ ¸å¿ƒé€»è¾‘å®Œæˆ

> **è®¾è®¡åŸåˆ™**ï¼šè¿™æ˜¯æ•´ä¸ªæµç¨‹çš„"è®¡ç®—ä¸­å¿ƒ"â€”â€”æ‰€æœ‰ä¸­é—´ç»“æœéƒ½ä»è¿™é‡Œäº§å‡ºï¼Œåç»­æ¨¡å—åªè¯»å–ã€‚

#### è¾“å…¥è§„èŒƒ

| è¾“å…¥ | æ¥æº | æ•°æ®ç»“æ„ |
|------|------|----------|
| é¢„å¤„ç†ç»“æœ | `preprocessing.py` | `PreprocessingResult` (data, sfreq, ch_names) |
| HFOäº‹ä»¶ | `hfo_detector.py` æˆ– `*_gpu.npz` | `Dict[ch_name â†’ np.ndarray (n,2)]` |
| æ‚£è€…çº§æ±‡æ€» | `_refineGpu.npz` | events_count (n_ch,), chns_names |
| æ ¸å¿ƒé€šé“ | `hist_meanX.npz` | pick_chns (8,) |
| äº‹ä»¶çª—å£ | `*_packedTimes.npy` | (n_events, 2) [start, end] ç§’ |

#### è¾“å‡ºè§„èŒƒ

| è¾“å‡ºæ–‡ä»¶ | å†…å®¹ | ä¸‹æ¸¸ç”¨æˆ· |
|----------|------|----------|
| `*_envCache_{band}_{ref}.npz` | envelope + (å¯é€‰x_band) + sfreq + ch_names | visualization (Fig1æ³¢å½¢) |
| `*_groupAnalysis.npz` | **è´¨å¿ƒ+lag+rank+baselineæ± å…ƒæ•°æ®ï¼ˆTFå¯é€‰ï¼‰** | visualization, network_analysis |

#### åŠŸèƒ½åˆ†è§£

| åŠŸèƒ½ | è¯´æ˜ | çŠ¶æ€ |
|------|------|------|
| 3.1 çª—å£æ„å»º | `build_windows_from_detections` | âœ… |
| 3.2 Envelopeç¼“å­˜ | `precompute_envelope_cache` | âœ… |
| 3.3 è´¨å¿ƒè®¡ç®— | `compute_centroid_matrix_from_envelope_cache` | âœ… |
| 3.4 Lag/Rank | `lag_rank_from_centroids` | âœ… |
| 3.5 TFè´¨å¿ƒ | `compute_tf_centroids`ï¼ˆwavelet+åŠ¨æ€åŸºçº¿ï¼‰ | âœ… |
| 3.6 ç»“æœå­˜å‚¨ | `save_group_analysis_results`, `load_group_analysis_results` | âœ… |
| 3.7 ä¸€é”®API | `compute_and_save_group_analysis` | âœ… |
| 3.7 é€šé“ç­›é€‰ | `select_core_channels_by_event_count` | âœ… |
| 3.8 éªŒè¯å‡½æ•° | `validate_*` ç³»åˆ— | âœ… |

**é…ç½®è¡¥å……ï¼ˆé»˜è®¤è¡Œä¸ºï¼‰**ï¼š
- `centroid_source='env'`ï¼šlag/rank é»˜è®¤åŸºäºåŒ…ç»œè´¨å¿ƒ
- `compute_tf_centroids=False`ï¼šTFè´¨å¿ƒé»˜è®¤ä¸è®¡ç®—ï¼ˆå¯é€‰å¼€å¯ï¼‰
- `save_bandpass=False`ï¼šx_band é»˜è®¤ä¸ä¿å­˜ï¼ˆä»…å¯è§†åŒ–éœ€è¦æ—¶å¼€å¯ï¼‰

**é˜¶æ®µæ€§ç»“è®ºï¼ˆ2026-01-16ï¼‰**:
- âœ… æ ¸å¿ƒé€šé“ç­›é€‰ï¼š`mean + 1*std` å¯å¤ç° `hist_meanX.npz` çš„ `pick_chns`
- âœ… packedTimes çª—å£é•¿åº¦ï¼šä» `packedTimes[:,1]-packedTimes[:,0]` æ¨æ–­
- âœ… Step1 éªŒè¯ï¼š`reference='bipolar'` + åˆ«åé€šé“ + GPUé€šé“è¿‡æ»¤ â†’ é«˜è¦†ç›–ç‡
- âœ… Step2-3 éªŒè¯ï¼š`eventsBool` 100% ä¸€è‡´ï¼›ç›¸å¯¹ lag è¾¾ ms çº§è¯¯å·®
- âœ… TFè´¨å¿ƒè®¡ç®—ï¼š`compute_tf_centroids` æ”¹ä¸º **wavelet+åŠ¨æ€åŸºçº¿**ï¼ˆéSTFTï¼‰ï¼Œé»˜è®¤å¯å…³é—­
- âœ… åŸºçº¿æ± ï¼š2sçª—/1sæ­¥é•¿ï¼Œæ’é™¤ictal+HFO+é«˜LL+é«˜Rippleï¼Œå­˜å…¥ `baseline_pool_starts/indices`
- âœ… ç»Ÿä¸€å­˜å‚¨ï¼š`save_group_analysis_results` + `load_group_analysis_results` å·²å®ç°
- âœ… ä¸€é”®APIï¼š`compute_and_save_group_analysis` å¯ä» EDF ä¸€ç«™å¼ç”Ÿæˆæ‰€æœ‰ä¸­é—´ç»“æœ

---

### æ¨¡å—4: src/network_analysis.py (å¼€å‘ä¸­)

> **æ ¸å¿ƒç›®æ ‡**ï¼šä» HFO ç¾¤ä½“äº‹ä»¶æ„å»ºä¸‹ä¸€ä»£ç™«ç—«ç½‘ç»œï¼Œå®ç° SOZ å®šä½ä¸ä¼ æ’­è·¯å¾„é¢„æµ‹ã€‚

---

#### 4.0 è®¾è®¡å“²å­¦ä¸æ‰¹åˆ¤æ€§å‰æ

**"å®½å»ºå›¾ â†’ ç²¾å‰ªæ â†’ å®šæ–¹å‘" ç­–ç•¥ (Build-Prune-Direct Strategy)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç™«ç—«ç½‘ç»œæ„å»ºæµæ°´çº¿ v2                                 â”‚
â”‚               "å®½å»ºå›¾ â†’ ç²¾å‰ªæ â†’ å®šæ–¹å‘"                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                        â”‚
â”‚  [å…¨é€šé“æ± ] (n_all â‰ˆ 120)                                              â”‚
â”‚      â”‚                                                                 â”‚
â”‚      â–¼                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  Step 1: å®½å»ºå›¾ (Broad Graph Construction)                  â”‚       â”‚
â”‚  â”‚  è¾¹æƒ = Simpson Index (å½’ä¸€åŒ–å…±æ¿€æ´»)                         â”‚       â”‚
â”‚  â”‚  "ä¸å†ç”¨åŸå§‹å…±æ¿€æ´»è®¡æ•°â€”â€”æ ¡æ­£åŸºç¡€ç‡åå·®"                       â”‚       â”‚
â”‚  â”‚  + Surrogate æ˜¾è‘—æ€§æ£€éªŒ â†’ å‰”é™¤éšæœºé‡åˆ                      â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                             â”‚                                          â”‚
â”‚                             â–¼                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  Step 2: XYZ å¤šç»´å‰ªæ (Multi-Dimensional Pruning)          â”‚       â”‚
â”‚  â”‚  X = HFO Rate (æ´»è·ƒåº¦) â†’ èŠ‚ç‚¹æ˜¯ç—…ç†æ´»åŠ¨å‘ç”Ÿè€…               â”‚       â”‚
â”‚  â”‚  Y = Connection Entropy (ç‰¹å¼‚æ€§) â†’ å‰”é™¤å…¨è„‘å™ªå£°/å‚è€ƒä¼ªè¿¹    â”‚       â”‚
â”‚  â”‚  Z = FR/R Ratio (è‡´ç—«æ€§) æˆ– è°±èšç±»(XYZè·ç¦»åº¦é‡)            â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                             â”‚                                          â”‚
â”‚                             â–¼                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  Step 3: æ–¹å‘æ³¨å…¥ (Direction Injection)                     â”‚       â”‚
â”‚  â”‚  Wilcoxon + ä¸€è‡´æ€§æ£€éªŒ â†’ æœ‰å‘è¾¹                             â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                             â”‚                                          â”‚
â”‚                             â–¼                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  Step 4: å¤åˆæƒé‡ + ç‰©ç†çº¦æŸ                                â”‚       â”‚
â”‚  â”‚  Simpson Ã— Consistency Ã— Stability                          â”‚       â”‚
â”‚  â”‚  + å®¹ç§¯ä¼ å¯¼å‰”é™¤ (<10mm, Phase B)                            â”‚       â”‚
â”‚  â”‚  + ä¼ æ’­é€Ÿåº¦éªŒè¯ (0.1-10 m/s, Phase B)                       â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                             â”‚                                          â”‚
â”‚                             â–¼                                          â”‚
â”‚  [åŠ æƒæœ‰å‘å›¾ G(V, E, W)]  â†’  å›¾è®ºæŒ‡æ ‡  â†’  SOZ/ä¼ æ’­è·¯å¾„                  â”‚
â”‚                                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ä¸ºä»€ä¹ˆæ˜¯ "å®½å»ºå›¾ â†’ ç²¾å‰ªæ" è€Œä¸æ˜¯æ—§ç‰ˆ "é€‰èŠ‚ç‚¹ â†’ å»ºéª¨æ¶"ï¼Ÿ**

| ç­–ç•¥ | è‡´å‘½ç¼ºé™· |
|------|---------|
| å…ˆé€‰èŠ‚ç‚¹å†å»ºè¾¹ | é€‰èŠ‚ç‚¹ç”¨çš„ co-activation æœ¬èº«è¢«åŸºç¡€ç‡åå·®æ±¡æŸ“ï¼Œåƒåœ¾è¿›åƒåœ¾å‡º |
| å…ˆå»ºéª¨æ¶å†é€‰èŠ‚ç‚¹ | éª¨æ¶çš„è¾¹æƒï¼ˆåŸå§‹ count/ratioï¼‰æ— æ³•åŒºåˆ†"çœŸåŒæ­¥"å’Œ"éšæœºé‡åˆ" |
| **å®½å»ºå›¾ â†’ ç²¾å‰ªæ** | Simpson å½’ä¸€åŒ–æ¶ˆé™¤ç‡åå·® â†’ XYZ å¤šç»´ç‹¬ç«‹å‰ªæï¼Œæ¯æ­¥å¯å®¡è®¡å¯å›æº¯ |

---

#### 4.1 ç°æœ‰èµ„äº§ç›˜ç‚¹ (Asset Inventory)

**âœ… å·²æœ‰æ•°æ®ï¼ˆgroupAnalysis.npzï¼‰**

| æ•°æ® | å½¢çŠ¶ | ç‰©ç†æ„ä¹‰ | ç½‘ç»œç”¨é€” |
|------|------|----------|---------|
| `ch_names` | (n_ch,) | æ ¸å¿ƒé€šé“å | èŠ‚ç‚¹æ ‡è¯† |
| `coact_all_ch_names` | (n_all,) | **å…¨é€šé“å** | æ‰©å¤§èŠ‚ç‚¹æ±  |
| `coact_event_ratio` | (n_ch, n_ch) | å…±æ¿€æ´»æ¦‚ç‡ | **éª¨æ¶æ„å»º** |
| `coact_all_event_ratio` | (n_all, n_all) | **å…¨é€šé“å…±æ¿€æ´»** | æ‰©å¤§èŠ‚ç‚¹æ±  |
| `lag_raw` | (n_ch, n_events) | è´¨å¿ƒæ—¶é—´ï¼ˆç›¸å¯¹çª—å£èµ·ç‚¹ï¼‰ | **æ–¹å‘è®¡ç®—** |
| `events_bool` | (n_ch, n_events) | é€šé“å‚ä¸mask | äº‹ä»¶è¿‡æ»¤ |
| `event_windows` | (n_events, 2) | äº‹ä»¶çª—å£ [start, end] | æ—¶é—´åˆ†æ®µ |

**å…³é”®æ•°æ®ç»“æ„æ´å¯Ÿ**ï¼š

```python
# lag_raw å­˜å‚¨çš„æ˜¯æ¯é€šé“ç›¸å¯¹äºçª—å£èµ·ç‚¹çš„è´¨å¿ƒæ—¶é—´
# è¦è·å¾—é€šé“å¯¹ (i, j) åœ¨äº‹ä»¶ k ä¸­çš„æ—¶æ»ï¼š
lag_ij_k = lag_raw[i, k] - lag_raw[j, k]  # è´Ÿå€¼ = i é¢†å…ˆ j

# è¿™æ˜¯ç´§å‡‘å­˜å‚¨ï¼šO(n_ch Ã— n_events) vs O(n_chÂ² Ã— n_events)
# è¿è¡Œæ—¶è®¡ç®—å·®å€¼ï¼Œç©ºé—´æ¢æ—¶é—´
```

**âš ï¸ ç¼ºå¤±æ•°æ®ï¼ˆéœ€è¦æ‰©å±•ï¼‰**

| æ•°æ® | å½¢çŠ¶ | æ¥æº | ä¼˜å…ˆçº§ | ç”¨é€” |
|------|------|------|--------|------|
| `electrode_distance` | (n_all, n_all) | MNIåæ ‡è®¡ç®— | **Phase B é˜»å¡** | å®¹ç§¯ä¼ å¯¼å‰”é™¤ã€ä¼ æ’­é€Ÿåº¦éªŒè¯ |
| `hfo_type_per_event` | (n_ch, n_events) | æ£€æµ‹å™¨è¾“å‡º | **Phase B** | ç—…ç†åŠ æƒ (FR æ¯”ä¾‹) |
| `tissue_label` | (n_all,) | FreeSurfer | Phase C | ç°/ç™½è´¨è¿‡æ»¤ï¼ˆä¸ç¡¬å‰”é™¤ï¼‰ |
| `mni_coords` | (n_all, 3) | é…å‡†ç»“æœ | **Phase B é˜»å¡** | 3Då¯è§†åŒ–ã€è·ç¦»çŸ©é˜µ |
| `lead_field_matrix` | (n_ch, n_sources) | BEM å‰å‘å»ºæ¨¡ | Phase C | æºç©ºé—´ LFM æ¦‚ç‡æŠ•å½± |
| `sc_matrix` | (n_regions, n_regions) | HCP tractography | Phase C | SC-FC è€¦åˆå›¾ |

---

#### 4.2 å®½å»ºå›¾ (Broad Graph Construction) â€” Simpson Index å½’ä¸€åŒ–å…±æ¿€æ´»

> "å»ºå›¾å®½è¿›ï¼Œå‰ªæä¸¥å‡ºã€‚" å…ˆæŠŠæ‰€æœ‰æœ‰æ„ä¹‰çš„è¿æ¥ä¿ç•™ä¸‹æ¥ï¼Œç”¨ç»Ÿè®¡å­¦ä¸Šæ­£ç¡®çš„æŒ‡æ ‡åº¦é‡ï¼Œå†åœ¨ä¸‹ä¸€æ­¥ç²¾ç¡®å‰ªæã€‚

##### 4.2.1 ä¸ºä»€ä¹ˆä¸èƒ½ç›´æ¥ç”¨ Co-activation Count å»ºè¾¹ï¼Ÿ

**è‡´å‘½ç¼ºé™·ï¼šåŸºç¡€ç‡åå·® (Base Rate Bias)**

å‡è®¾èŠ‚ç‚¹ A åªæœ‰ 10 æ¬¡ HFOï¼ŒèŠ‚ç‚¹ B æœ‰ 1000 æ¬¡ã€‚A çš„ 10 æ¬¡**å…¨éƒ¨**ä¼´éš B å‘ç”Ÿï¼ˆ100% å¿…ç„¶è·Ÿéšï¼‰ï¼š

| æŒ‡æ ‡ | è®¡ç®— | ç»“æœ | é—®é¢˜ |
|------|------|------|------|
| Raw Count | $\|E_A \cap E_B\| = 10$ | 10 | è¢« B çš„ 1000 æ¬¡æ·¹æ²¡ï¼Œçœ‹èµ·æ¥"ä¸é‡è¦" |
| Jaccard | $\frac{10}{10 + 1000 - 10}$ | 1% | åˆ†æ¯è¢« B çš„è§„æ¨¡ç¨€é‡Š |
| Dice | $\frac{2 \times 10}{10 + 1000}$ | 2% | åŒä¸Šï¼Œç¨å¥½ä½†ä»è¢«ç¨€é‡Š |
| **Simpson** | $\frac{10}{\min(10, 1000)}$ | **100%** | å®Œç¾æ•æ‰"A å¿…ç„¶è·Ÿéš B" |

**åœ¨ç™«ç—«ç½‘ç»œä¸­ï¼Œ"å¿…ç„¶è·Ÿéš"æ¯”"å…±åŒæ´»è·ƒ"æ›´é‡è¦**ï¼š
- çœŸæ­£çš„"èµ·æå™¨"å¯èƒ½å‘æ”¾ç‡ä¸é«˜ï¼Œä½†æ¯æ¬¡å‘æ”¾éƒ½å¿…ç„¶å¸¦åŠ¨ä¸‹æ¸¸
- ä¼ æ’­é€šè·¯èŠ‚ç‚¹çš„ç‰¹å¾æ˜¯ï¼šå®ƒçš„æ¯æ¬¡ HFO éƒ½ä¼´éšä¸Šæ¸¸ Source å‘æ”¾
- Simpson Index å¤©ç„¶æ•æ‰è¿™ç§ä¸å¯¹ç§°çš„åŒ…å«å…³ç³»

##### 4.2.2 æ¨èè¾¹æƒæŒ‡æ ‡ï¼šSimpson Index

$$W_{ij}^{Simpson} = \frac{|E_i \cap E_j|}{\min(|E_i|, |E_j|)}$$

**å¤‡é€‰**ï¼ˆä¾›å¯¹æ¯”éªŒè¯ï¼‰ï¼š

$$W_{ij}^{Dice} = \frac{2 \cdot |E_i \cap E_j|}{|E_i| + |E_j|}$$

| æŒ‡æ ‡ | å…¬å¼ | åå‘ | é€‚ç”¨åœºæ™¯ |
|------|------|------|----------|
| **Simpson** (æ¨è) | $\frac{\|E_i \cap E_j\|}{\min(\|E_i\|, \|E_j\|)}$ | æ•æ‰åŒ…å«/è·Ÿéšå…³ç³» | ç™«ç—«ä¼ æ’­ç½‘ç»œï¼ˆä¸å¯¹ç§°è€¦åˆï¼‰ |
| Dice (å¤‡é€‰) | $\frac{2\|E_i \cap E_j\|}{\|E_i\| + \|E_j\|}$ | å¯¹ç§°ï¼Œæ¸©å’Œå½’ä¸€åŒ– | ä¸€èˆ¬å…±æ¿€æ´»ç½‘ç»œ |
| Jaccard | $\frac{\|E_i \cap E_j\|}{\|E_i \cup E_j\|}$ | æƒ©ç½šä¸å¯¹ç§°å¯¹ | âŒ ä¸æ¨èï¼šç¨€é‡Šä½é¢‘èŠ‚ç‚¹ |
| Raw Count/Ratio | $\|E_i \cap E_j\|$ æˆ– $/ N$ | éšç‡ç¼©æ”¾ | âŒ ä¸æ¨èï¼šé«˜é¢‘èŠ‚ç‚¹ä¸»å¯¼ |

**é»˜è®¤é€‰æ‹© Simpson çš„ç†ç”±**ï¼š
1. ç™«ç—«ç½‘ç»œçš„æ ¸å¿ƒé—®é¢˜æ˜¯è¯†åˆ«"è°è·Ÿéšè°"ï¼ŒSimpson æ­£æ˜¯åº¦é‡åŒ…å«å…³ç³»çš„æŒ‡æ ‡
2. Simpson çš„ä¸å¯¹ç§°åå·®ä¼šè¢« Step 2 çš„ HFO Rate (X) å‰ªææ ¡æ­£ â€” ç‡å¤ªä½çš„èŠ‚ç‚¹ä¼šè¢«å‰”é™¤
3. Simpson å¯¹"æ²‰é»˜çš„å…±çŠ¯"å‹å¥½ â€” ä½é¢‘ä½† 100% è·Ÿéšçš„èŠ‚ç‚¹ä¸ä¼šè¢«é—æ¼

##### 4.2.3 æ•°æ®æ¥æºä¸å‘é‡åŒ–å®ç°

**å…³é”®æ´å¯Ÿ**ï¼šæ‰€æœ‰éœ€è¦çš„æ•°æ®å·²å­˜åœ¨äº `*_groupAnalysis.npz`ï¼š

```python
# æ•°æ®æ¥æºæ˜ å°„
intersection = coact_all_event_count[i, j]   # |E_i âˆ© E_j|
event_count_i = coact_all_event_count[i, i]  # |E_i| (å¯¹è§’çº¿ = è‡ªèº«äº‹ä»¶æ•°)
event_count_j = coact_all_event_count[j, j]  # |E_j|
```

**å‘é‡åŒ–å®ç°** (N=120, <1ms)ï¼š

```python
def build_broad_graph(
    coact_event_count: np.ndarray,    # (n_all, n_all) å…±æ¿€æ´»äº‹ä»¶è®¡æ•°çŸ©é˜µ
    method: str = 'simpson',          # 'simpson' | 'dice'
    significance_mask: Optional[np.ndarray] = None,  # surrogate æ£€éªŒç»“æœ
) -> np.ndarray:
    """
    ä»å…±æ¿€æ´»è®¡æ•°çŸ©é˜µæ„å»ºå½’ä¸€åŒ–è¾¹æƒå›¾ã€‚

    Simpson: W_ij = |E_i âˆ© E_j| / min(|E_i|, |E_j|)
    Dice:    W_ij = 2|E_i âˆ© E_j| / (|E_i| + |E_j|)

    Returns: (n_all, n_all) å¯¹ç§°è¾¹æƒçŸ©é˜µ, å€¼åŸŸ [0, 1]
    """
    intersection = coact_event_count.astype(np.float64).copy()
    events_count = np.diag(coact_event_count).astype(np.float64)  # |E_i|
    np.fill_diagonal(intersection, 0.0)

    if method == 'simpson':
        denom = np.minimum.outer(events_count, events_count)
    elif method == 'dice':
        denom = np.add.outer(events_count, events_count) / 2.0
    else:
        raise ValueError(f"Unknown method: {method}. Use 'simpson' or 'dice'.")

    W = np.divide(
        intersection, denom,
        out=np.zeros_like(intersection),
        where=denom > 0,
    )

    # å¯¹ç§°åŒ–ï¼ˆSimpson å¯èƒ½å› æµ®ç‚¹ä¸å®Œå…¨å¯¹ç§°ï¼‰
    W = np.maximum(W, W.T)

    # æ˜¾è‘—æ€§é—¨æ§ï¼ˆå¯é€‰ï¼‰
    if significance_mask is not None:
        W[~significance_mask] = 0.0

    np.fill_diagonal(W, 0.0)
    return W
```

##### 4.2.4 Surrogate æ˜¾è‘—æ€§æ£€éªŒï¼ˆä¿ç•™ï¼Œé€»è¾‘ä¸å˜ï¼‰

> å…±æ¿€æ´»çš„"ç»Ÿè®¡æ˜¾è‘—"ä¸ç­‰äº"ç‰©ç†çœŸå®"ã€‚å³ä½¿ç”¨äº† Simpson å½’ä¸€åŒ–ï¼Œä¹Ÿå¿…é¡»éªŒè¯è§‚æµ‹å€¼æ˜¯å¦æ˜¾è‘—é«˜äºéšæœºã€‚

```python
def surrogate_significance_test(
    events_bool: np.ndarray,       # (n_ch, n_events) å‚ä¸mask
    n_surrogates: int = 200,       # æ›¿ä»£æ•°æ®é›†æ•°é‡
    p_threshold: float = 0.05,     # æ˜¾è‘—æ€§é˜ˆå€¼
) -> np.ndarray:
    """
    ç‹¬ç«‹å¾ªç¯å¹³ç§»å„é€šé“äº‹ä»¶åºåˆ—ç”Ÿæˆæ›¿ä»£æ•°æ®é›†ï¼Œ
    éªŒè¯çœŸå® Simpson/Dice å…±æ¿€æ´»æ˜¯å¦æ˜¾è‘—é«˜äºéšæœºé¢„æœŸã€‚

    Returns: (n_ch, n_ch) bool â€” æ˜¾è‘—æ€§ mask
    """
    # å®ç°é€»è¾‘åŒä¹‹å‰ï¼šcircular shift â†’ é‡ç®— â†’ p-value
    ...
```

##### 4.2.5 å®½å»ºå›¾çš„è®¾è®¡çº¦æŸ

**âš ï¸ å…³é”®åŸåˆ™**ï¼š

- âœ… **å®½è¿›**ï¼šæ­¤æ­¥ä¸åšä»»ä½•èŠ‚ç‚¹å‰”é™¤ï¼Œä¿ç•™æ‰€æœ‰æœ‰ HFO çš„é€šé“
- âœ… **å½’ä¸€åŒ–**ï¼šSimpson/Dice æ¶ˆé™¤åŸºç¡€ç‡åå·®
- âœ… **ç»Ÿè®¡é—¨æ§**ï¼šSurrogate å‰”é™¤éšæœºé‡åˆè¾¹ï¼ˆå¯é€‰ä½†æ¨èï¼‰
- âŒ **ä¸åšé˜ˆå€¼å‰ªæ**ï¼šä¸è®¾ `min_coact` â€” é‚£æ˜¯ Step 2 çš„æ´»
- âŒ **ä¸åšèŠ‚ç‚¹é€‰æ‹©**ï¼šä¸åœ¨è¿™é‡Œç”¨è°±èšç±» â€” é‚£ä¹Ÿæ˜¯ Step 2 çš„æ´»
- âŒ **ä¸åšè·ç¦»çº¦æŸ**ï¼šPhase A æ—  MNI åæ ‡ï¼ŒPhase B å†åŠ 

**è¾“å‡º**ï¼š`W_broad` â€” (n_all, n_all) å½’ä¸€åŒ–çš„å¯¹ç§°è¾¹æƒçŸ©é˜µï¼Œå€¼åŸŸ [0, 1]

---

#### 4.3 XYZ å¤šç»´å‰ªæ (Multi-Dimensional Pruning) â€” ä»å¹¿æ³›å›¾ä¸­æå–ç—…ç†ç½‘ç»œ

> "å»ºå›¾å®½è¿›ï¼Œå‰ªæä¸¥å‡ºã€‚" ä¸‰ä¸ªæ­£äº¤ç»´åº¦ï¼Œæ¯ä¸ªç»´åº¦ç„å‡†ä¸€ç±»ç‰¹å®šçš„å™ªå£°æºã€‚

##### 4.3.1 ä¸‰ç»´åº¦æ¡†æ¶æ€»è§ˆ

```
              é«˜                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚                    â”‚  SOZ æ ¸å¿ƒ (ä¿ç•™)      â”‚
               â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  é«˜ç‡ + ä½ç†µ + é«˜ Z   â”‚
    X: HFO    â”‚       â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    Rate       â”‚       â”‚
   (æ´»è·ƒåº¦)    â”‚       â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚       â”‚    â”‚  å‚è€ƒä¼ªè¿¹ (å‰”é™¤)      â”‚
               â”‚       â”‚    â”‚  é«˜ç‡ + é«˜ç†µ           â”‚
              ä½       â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
              ä½        â”‚                            é«˜
                 Y: Connection Entropy (ç‰¹å¼‚æ€§)
```

| ç»´åº¦ | æŒ‡æ ‡ | ç‰©ç†æ„ä¹‰ | å‰ªææ–¹å‘ | Phase |
|------|------|----------|----------|-------|
| **X (Activity)** | HFO Rate ($events/min$) | èŠ‚ç‚¹æ˜¯å¦æ˜¯ç—…ç†æ´»åŠ¨çš„æ´»è·ƒå‘ç”Ÿè€… | ä¿ç•™ $X > X_{min}$ | **A** |
| **Y (Specificity)** | Connection Entropy $\hat{H}_i$ | è¿æ¥æ˜¯ç‰¹å¼‚æ€§çš„è¿˜æ˜¯å…¨è„‘å¼¥æ•£çš„ | ä¿ç•™ $\hat{H} < H_{max}$ | **A** |
| **Z (Epileptogenicity)** | FR/R Ratio æˆ– è°±èšç±»(XYZè·ç¦») | èŠ‚ç‚¹çš„è‡´ç—«æ€§ç‰¹å¼‚åº¦ | Phase A: è°±èšç±»; Phase B: FRæ¯”ä¾‹ | **A/B** |

##### 4.3.2 ç»´åº¦ X â€” HFO Rate (æ´»è·ƒåº¦)

$$X_i = \frac{|E_i|}{T_{recording}} \quad (\text{events/min})$$

- **ç‰©ç†æ„ä¹‰**ï¼šèŠ‚ç‚¹æ˜¯å¦äº§ç”Ÿè¶³å¤Ÿå¤šçš„ HFO æ¥è¢«çº³å…¥ç½‘ç»œåˆ†æ
- **å‰ªæé€»è¾‘**ï¼š$X_i \geq X_{min}$
- **é»˜è®¤é˜ˆå€¼**ï¼š`min_rate = 0.5 events/min`ï¼ˆæ¯2åˆ†é’Ÿè‡³å°‘1æ¬¡ HFOï¼‰
- **âš ï¸ ä¸è¦è®¾å¤ªé«˜**ï¼šçœŸæ­£çš„"èµ·æå™¨"å¯èƒ½å‘æ”¾ç‡ä¸é«˜ä½†æ¯æ¬¡å¿…ç„¶å¸¦åŠ¨ä¸‹æ¸¸ï¼ˆSimpson å·²æ•æ‰è¿™ç§å…³ç³»ï¼‰

##### 4.3.3 ç»´åº¦ Y â€” Connection Entropy (ç‰¹å¼‚æ€§) ğŸ”‘ æ ¸å¿ƒåˆ›æ–°

**å®šä¹‰**ï¼šç»™å®šèŠ‚ç‚¹ $i$ åœ¨å®½å»ºå›¾ $W$ ä¸­çš„è¿æ¥æƒé‡åˆ†å¸ƒï¼š

$$p_{ij} = \frac{W_{ij}}{\sum_{k \neq i} W_{ik}}, \quad H_i = -\sum_{j \neq i} p_{ij} \ln p_{ij}$$

**å½’ä¸€åŒ–ç†µ**ï¼ˆæ˜ å°„åˆ° [0, 1]ï¼‰ï¼š

$$\hat{H}_i = \frac{H_i}{\ln(N_{neighbors,i})}$$

å…¶ä¸­ $N_{neighbors,i}$ = èŠ‚ç‚¹ $i$ çš„éé›¶è¿æ¥æ•°ã€‚

**ç‰©ç†è§£é‡Š**ï¼š

| $\hat{H}_i$ | å«ä¹‰ | ç½‘ç»œè§’è‰² | åˆ¤å®š |
|---|---|---|---|
| **â‰ˆ 0** | è¿æ¥é›†ä¸­äº1-2ä¸ªèŠ‚ç‚¹ | é«˜åº¦ç‰¹å¼‚çš„"å…±çŠ¯å…³ç³»" | âœ… ä¿ç•™ï¼ˆå±€ç¶æ€§ä¼ æ’­é€šè·¯ï¼‰ |
| **0.3 - 0.6** | ä¸­ç­‰åˆ†æ•£ | æœ‰é€‰æ‹©æ€§çš„ Hub | âœ… ä¿ç•™ |
| **â‰ˆ 1.0** | å‡åŒ€è¿æ¥æ‰€æœ‰èŠ‚ç‚¹ | å…¨è„‘åŒæ­¥ï¼ˆä¼ªè¿¹/å™ªå£°ï¼‰ | âŒ å‰”é™¤ |

**ä¸ºä»€ä¹ˆ Connection Entropy æ˜¯å‰”é™¤ Global Artifacts çš„"ç¥æŠ€"**ï¼š

Reference contamination çš„æ•°å­¦ç‰¹å¾ï¼šä¸€ä¸ªé€šé“å› å…±å‚è€ƒç”µæè€Œä¸æ‰€æœ‰é€šé“äº§ç”Ÿè™šå‡"å…±æ¿€æ´»"ã€‚åœ¨ Simpson ç©ºé—´ä¸­ï¼Œè¿™ä¸ªé€šé“ä¸æ¯ä¸ªå…¶ä»–é€šé“çš„ Simpson å€¼éƒ½ > 0ï¼ˆå› ä¸ºå®ƒçš„æ¯æ¬¡ HFO éƒ½"ä¼´éš"å¾ˆå¤šé€šé“ï¼‰ã€‚**ä½†å®ƒçš„è¿æ¥åˆ†å¸ƒæ¥è¿‘å‡åŒ€** â†’ $\hat{H} \approx 1.0$ã€‚

çœŸæ­£çš„ç—…ç†é€šé“åªä¸ç½‘ç»œå†…çš„ç‰¹å®š"å…±çŠ¯"é«˜åº¦åŒæ­¥ â†’ $\hat{H}$ æ˜¾è‘—ä½äº 1.0ã€‚

è¿™æ¯”ä¼ ç»Ÿçš„"å‰”é™¤ä¸å¤ªå¤šé€šé“è¿æ¥çš„èŠ‚ç‚¹"æ›´ç²¾ç¡®â€”â€”å®ƒä¸å…³å¿ƒä½ è¿äº†å¤šå°‘é€šé“ï¼Œè€Œå…³å¿ƒä½ çš„è¿æ¥æ˜¯å¦æœ‰**é€‰æ‹©æ€§**ã€‚

**å‰ªæé€»è¾‘**ï¼š$\hat{H}_i < H_{max}$ï¼Œé»˜è®¤ `max_entropy = 0.85`

```python
def compute_connection_entropy(W: np.ndarray) -> np.ndarray:
    """
    è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„å½’ä¸€åŒ–è¿æ¥ç†µã€‚

    Parameters
    ----------
    W : (n, n) è¾¹æƒçŸ©é˜µ (Simpson/Diceï¼Œå¯¹è§’çº¿ä¸º0)

    Returns
    -------
    H_norm : (n,) å½’ä¸€åŒ–ç†µï¼Œ0=æåº¦ç‰¹å¼‚ï¼Œ1=å‡åŒ€å¼¥æ•£
    """
    n = W.shape[0]
    H_norm = np.ones(n, dtype=np.float64)  # é»˜è®¤æœ€å¤§ç†µï¼ˆæœ€åæƒ…å†µï¼‰

    for i in range(n):
        w_i = W[i].copy()
        w_i[i] = 0.0
        total = w_i.sum()
        if total < 1e-10:
            continue  # å­¤ç«‹èŠ‚ç‚¹ï¼Œä¿æŒé»˜è®¤
        p = w_i / total
        nonzero = p > 0
        n_neighbors = nonzero.sum()
        if n_neighbors < 2:
            H_norm[i] = 0.0  # åªæœ‰1ä¸ªè¿æ¥ = æœ€å¤§ç‰¹å¼‚æ€§
            continue
        H = -np.sum(p[nonzero] * np.log(p[nonzero]))
        H_max = np.log(n_neighbors)
        H_norm[i] = H / H_max if H_max > 0 else 1.0

    return H_norm
```

##### 4.3.4 ç»´åº¦ Z â€” Epileptogenicity (è‡´ç—«æ€§)

**Phase Aï¼ˆæ—  FR åˆ†ç±»æ•°æ®ï¼‰**ï¼š

åœ¨ X-Y ç©ºé—´ä¸­ç”¨è°±èšç±»ï¼Œä»¥ Simpson è¿æ¥æƒé‡ä¸ºäº²å’Œåº¦ã€ä»¥ XY ç‰¹å¾ä¸ºè¾…åŠ©è·ç¦»åº¦é‡ï¼š

$$A_{ij}^{cluster} = W_{ij}^{Simpson} \times \exp\left(-\frac{(\hat{X}_i - \hat{X}_j)^2 + (\hat{Y}_i - \hat{Y}_j)^2}{2\sigma^2}\right)$$

- è°±èšç±»åœ¨æ­¤ä½œä¸º"è‡ªé€‚åº”ç¤¾åŒºå‘ç°"å·¥å…·
- Eigengap è‡ªåŠ¨ç¡®å®šèšç±»æ•°ï¼ˆä¸ç¡¬ç¼–ç  N=8ï¼‰
- å°äº `min_cluster_size` çš„å­¤ç«‹ç°‡è¢«æ ‡è®°ä¸ºå™ªå£°

**Phase Bï¼ˆæœ‰ FR åˆ†ç±»æ•°æ®åï¼‰**ï¼š

$$Z_i = \frac{N_{FR,i}}{N_{Ripple,i} + N_{FR,i}}$$

**æ›´æ¿€è¿›çš„ XYZ è·ç¦»åº¦é‡**ï¼ˆPhase Bï¼‰ï¼š

$$d_{ij}^{XYZ} = \sqrt{w_X(\hat{X}_i - \hat{X}_j)^2 + w_Y(\hat{Y}_i - \hat{Y}_j)^2 + w_Z(\hat{Z}_i - \hat{Z}_j)^2}$$

è°±èšç±»ä½¿ç”¨ $A_{ij} = W_{ij}^{Simpson} \times \exp(-d_{ij}^{XYZ}/2\sigma^2)$ ä½œä¸ºäº²å’ŒçŸ©é˜µï¼ŒåŒæ—¶ç¼–ç **è¿æ¥å¼ºåº¦**å’Œ**ç—…ç†ç‰¹å¾ç›¸ä¼¼æ€§**ã€‚

##### 4.3.5 å®Œæ•´å‰ªæ API

```python
def compute_node_xyz(
    W_broad: np.ndarray,               # (n_all, n_all) Simpson å®½å»ºå›¾
    events_count: np.ndarray,           # (n_all,) æ¯é€šé“ HFO äº‹ä»¶æ•°
    recording_duration_min: float,      # è®°å½•æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
    fr_ratio: Optional[np.ndarray] = None,  # (n_all,) FR/(R+FR) (Phase B)
) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """
    è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„ XYZ ä¸‰ç»´ç—…ç†ç‰¹å¾ã€‚

    Returns
    -------
    X : (n_all,) HFO Rate (events/min)
    Y : (n_all,) Normalized Connection Entropy (0=specific, 1=diffuse)
    Z : (n_all,) Epileptogenicity (Phase A: zeros; Phase B: FR ratio)
    """
    X = events_count.astype(np.float64) / max(recording_duration_min, 1e-6)
    Y = compute_connection_entropy(W_broad)
    Z = fr_ratio.copy() if fr_ratio is not None else np.zeros_like(X)
    return X, Y, Z


def prune_network(
    W_broad: np.ndarray,               # (n_all, n_all) å®½å»ºå›¾
    X: np.ndarray,                     # HFO Rate
    Y: np.ndarray,                     # Connection Entropy
    Z: np.ndarray,                     # Epileptogenicity
    *,
    min_rate: float = 0.5,             # X: æœ€ä½ HFO Rate (events/min)
    max_entropy: float = 0.85,         # Y: æœ€é«˜å½’ä¸€åŒ–è¿æ¥ç†µ
    use_spectral: bool = True,         # Z: åœ¨ XY+Simpson ç©ºé—´åšè°±èšç±»
    min_cluster_size: int = 3,
    n_clusters: Optional[int] = None,  # None = Eigengap è‡ªåŠ¨
) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """
    XYZ å¤šç»´å‰ªæï¼šä»å®½å»ºå›¾ä¸­æå–ç—…ç†ç½‘ç»œæ ¸å¿ƒã€‚

    Pipeline:
    1. X é—¨æ§ â†’ å‰”é™¤ä½æ´»è·ƒåº¦èŠ‚ç‚¹
    2. Y é—¨æ§ â†’ å‰”é™¤é«˜ç†µï¼ˆå…¨è„‘å¼¥æ•£ï¼‰èŠ‚ç‚¹
    3. Z é—¨æ§ â†’ è°±èšç±» (Phase A) æˆ– FR æ¯”ä¾‹ç­›é€‰ (Phase B)

    Returns
    -------
    selected_idx : (n_sel,) å…¥é€‰èŠ‚ç‚¹çš„å…¨é€šé“æ± ç´¢å¼•
    W_pruned : (n_sel, n_sel) å‰ªæåçš„è¾¹æƒå­å›¾
    cluster_labels : (n_all,) èšç±»æ ‡ç­¾ (-1=å‰”é™¤)
    """
    n = W_broad.shape[0]
    labels = np.full(n, -1, dtype=np.int32)

    # Step 1: X é—¨æ§ â€” æ´»è·ƒåº¦
    x_pass = X >= min_rate

    # Step 2: Y é—¨æ§ â€” ç‰¹å¼‚æ€§ï¼ˆå‰”é™¤é«˜ç†µ = ä¼ªè¿¹/å¼¥æ•£å™ªå£°ï¼‰
    y_pass = Y <= max_entropy

    # è”åˆ mask
    node_mask = x_pass & y_pass
    candidate_idx = np.where(node_mask)[0]

    if len(candidate_idx) < min_cluster_size + 1:
        # å€™é€‰å¤ªå°‘ï¼Œé€€åŒ–ä¸ºå…¨éƒ¨ä¿ç•™
        selected_idx = candidate_idx
        labels[candidate_idx] = 0
    elif use_spectral:
        # Step 3: è°±èšç±» â†’ è¯†åˆ«ç—…ç†ç½‘ç»œç¤¾åŒºï¼Œå‰”é™¤å­¤ç«‹å™ªå£°
        W_sub = W_broad[np.ix_(candidate_idx, candidate_idx)]
        sub_labels, _ = extract_network_clusters(
            W_sub, min_cluster_size, n_clusters,
        )
        # æ˜ å°„å›å…¨é€šé“ç´¢å¼•
        for si, ci in enumerate(candidate_idx):
            labels[ci] = sub_labels[si]
        selected_idx = candidate_idx[sub_labels >= 0]
    else:
        selected_idx = candidate_idx
        labels[candidate_idx] = 0

    W_pruned = W_broad[np.ix_(selected_idx, selected_idx)]
    return selected_idx, W_pruned, labels
```

##### 4.3.6 å…¸å‹æ¡ˆä¾‹ï¼šXYZ å¦‚ä½•åŒºåˆ†çœŸç½‘ç»œä¸ä¼ªè¿¹

| åœºæ™¯ | HFO Rate (X) | Entropy (Y) | FR Ratio (Z) | åˆ¤å®š |
|------|---|---|---|---|
| SOZ æ ¸å¿ƒ | é«˜ (8/min) | **ä½** (0.2) | é«˜ (0.6) | âœ… ä¿ç•™ â€” é«˜æ´»è·ƒã€ç‰¹å¼‚è¿æ¥ã€é«˜è‡´ç—«æ€§ |
| ä¼ æ’­é€šè·¯ | ä¸­ (2/min) | **ä½** (0.3) | ä¸­ (0.3) | âœ… ä¿ç•™ â€” æ´»è·ƒä¸”æœ‰é€‰æ‹©æ€§ |
| å‚è€ƒä¼ªè¿¹ | é«˜ (10/min) | **æé«˜** (0.95) | ä½ (0.1) | âŒ Y å‰”é™¤ â€” ä¸æ‰€æœ‰é€šé“å‡åŒ€è¿æ¥ |
| ç”Ÿç†æ€§ HFO | ä¸­ (1.5/min) | ä¸­ (0.5) | **æä½** (0.02) | âš ï¸ X ä¿ç•™, Y ä¿ç•™, Z ä½ â†’ è¢«è°±èšç±»æ ‡è®°ä¸ºè¾¹ç¼˜/å™ªå£° |
| å®‰é™å…³é”®èŠ‚ç‚¹ | **ä½** (0.3/min) | **æä½** (0.1) | é«˜ (0.5) | âŒ X å‰”é™¤ â€” æ´»è·ƒåº¦ä¸è¶³ï¼ˆSimpson å·²è®°å½•å…¶è·Ÿéšå…³ç³»ï¼Œåç»­å¯å›æº¯ï¼‰ |

##### 4.3.7 å·¥ç¨‹çº¦æŸä¸é€€åŒ–ç­–ç•¥

**âš ï¸ å…³é”®çº¦æŸ**ï¼š
- âŒ ä¸è¦ä»…ç”¨ç™½è´¨æ ‡ç­¾å‰”é™¤ â€” ç°è´¨å¼‚ä½/è„‘å®¤å‘¨å›´ç»“èŠ‚ä½äºæ·±éƒ¨ç™½è´¨ä½† HFO é«˜å‘
- âŒ ä¸è¦ç¡¬ç¼–ç é€šé“æ•° â€” è®©è°±èšç±»çš„ Eigengap æˆ– XY é˜ˆå€¼è‡ªé€‚åº”å†³å®š
- âœ… æ‰€æœ‰é˜ˆå€¼ï¼ˆmin_rate, max_entropyï¼‰å¿…é¡»å¯é…ç½® â€” æ‚£è€…é—´å·®å¼‚å¤§
- âœ… Eigengap ä¸ç¨³å®šæ—¶ï¼Œ`n_clusters` å¯æ‰‹åŠ¨è¦†ç›–
- âœ… è¢«å‰”é™¤çš„èŠ‚ç‚¹ä¿¡æ¯ä¿ç•™åœ¨ `cluster_labels` ä¸­ï¼Œå¯éšæ—¶å›æº¯

**é€€åŒ–ç­–ç•¥**ï¼ˆå½“ XYZ å‰ªæè¿‡äºæ¿€è¿›æ—¶ï¼‰ï¼š

```python
# ä¿åº•ï¼šåªç”¨ X é—¨æ§ + å¼± Y é—¨æ§
selected = np.where((X >= min_rate) & (Y <= 0.95))[0]
```

---

#### 4.4 æ–¹å‘æ³¨å…¥ (Direction Injection) â€” å‰ªæå›¾å‡çº§ä¸ºæœ‰å‘å›¾

**æ ¸å¿ƒæ”¹è¿›ï¼šç»Ÿè®¡é²æ£’æ€§**

> **æ‰¹åˆ¤**ï¼šç›´æ¥ç”¨ä¸­ä½æ•° Lag å®šå‘æ˜¯å±é™©çš„ã€‚å¤šå³°åˆ†å¸ƒï¼ˆç›´æ¥é€šè·¯ 5ms + é—´æ¥é€šè·¯ 25msï¼‰çš„ä¸­ä½æ•° 15ms åœ¨ç‰©ç†ä¸Šæ²¡æœ‰æ„ä¹‰ã€‚

**é²æ£’æ–¹å‘åˆ¤å®šæµç¨‹**ï¼š

```python
from scipy.stats import wilcoxon

def inject_direction(
    W_pruned: np.ndarray,           # (n_sel, n_sel) å‰ªæåçš„ Simpson è¾¹æƒå›¾
    lag_raw: np.ndarray,            # (n, n_events) è´¨å¿ƒæ—¶é—´
    events_bool: np.ndarray,        # (n, n_events) å‚ä¸mask
    min_events: int = 5,            # æœ€å°æ ·æœ¬é‡
    lag_thresh_ms: float = 5.0,     # é›¶æ»åé˜ˆå€¼
    consistency_thresh: float = 0.6, # æ–¹å‘ä¸€è‡´æ€§é˜ˆå€¼
    p_value_thresh: float = 0.05,   # æ˜¾è‘—æ€§é˜ˆå€¼
) -> Tuple[np.ndarray, np.ndarray]:
    """
    è¿”å›:
        adj_directed: (n, n) æœ‰å‘é‚»æ¥çŸ©é˜µï¼ŒA[i,j] = iâ†’j çš„æƒé‡
        edge_stats: dict åŒ…å«æ¯æ¡è¾¹çš„ç»Ÿè®¡ä¿¡æ¯
    """
    n = skeleton.shape[0]
    adj = np.zeros((n, n), dtype=np.float64)
    
    for i in range(n):
        for j in range(i+1, n):
            if not skeleton[i, j]:
                continue
            
            # æå–å…±åŒäº‹ä»¶çš„ lag
            mask = events_bool[i] & events_bool[j]
            if mask.sum() < min_events:
                continue
            
            lags = lag_raw[i, mask] - lag_raw[j, mask]  # è´Ÿ = i é¢†å…ˆ
            
            # === ç»Ÿè®¡æ£€éªŒ ===
            
            # 1. Wilcoxon æ£€éªŒï¼šLag æ˜¯å¦æ˜¾è‘—å¼‚äº 0ï¼Ÿ
            try:
                _, p_val = wilcoxon(lags)
            except ValueError:  # å…¨é›¶æˆ–æ ·æœ¬å¤ªå°‘
                continue
            
            if p_val > p_value_thresh:
                continue  # é›¶æ»ååŒæ­¥ï¼Œä¸å®šå‘
            
            # 2. æ–¹å‘ä¸€è‡´æ€§æ£€éªŒ
            median_lag = np.median(lags)
            if abs(median_lag) < lag_thresh_ms * 1e-3:
                continue  # å¤ªæ¥è¿‘é›¶ï¼Œä¸å®šå‘
            
            direction = np.sign(median_lag)
            consistency = np.mean(np.sign(lags) == direction)
            
            if consistency < consistency_thresh:
                continue  # æ–¹å‘å¤ªä¹±ï¼Œè§†ä¸ºæ¹æµ
            
            # 3. èµ‹äºˆæ–¹å‘
            if median_lag < 0:  # i é¢†å…ˆ j
                adj[i, j] = consistency
            else:              # j é¢†å…ˆ i
                adj[j, i] = consistency
    
    return adj
```

**å…³é”®ç»Ÿè®¡ä¿æŠ¤**ï¼š

| æ£€éªŒ | ç›®çš„ | å¤±è´¥å¤„ç† |
|------|------|---------|
| Wilcoxon | Lag â‰  0ï¼Ÿ | ä¸å®šå‘ï¼ˆè§†ä¸ºåŒæ­¥ï¼‰ |
| ä¸€è‡´æ€§ | æ–¹å‘ç¨³å®šï¼Ÿ | ä¸å®šå‘ï¼ˆè§†ä¸ºæ¹æµï¼‰ |
| æ ·æœ¬é‡ | n â‰¥ 5ï¼Ÿ | ä¸å»ºè¾¹ï¼ˆæ•°æ®ä¸è¶³ï¼‰ |

---

#### 4.5 æƒé‡å®šä¹‰ (Weight Definition) â€” å¤šç»´å¤åˆæƒé‡

> å•ä¸€æƒé‡æ— æ³•æ•æ‰è‡´ç—«ç½‘ç»œçš„å¤æ‚æ€§ã€‚å¿…é¡»èåˆå› æœæ€§ã€ç¨³å®šæ€§ä¸ç—…ç†ç‰¹å¼‚æ€§ã€‚

##### 4.5.1 ä¸‰ç»´æƒé‡æ¨¡å‹

$$W_{ij} = \underbrace{\text{Simpson}_{ij} \times \text{Consistency}_{ij}}_{\text{Causalityï¼ˆå› æœæ€§ï¼‰}} \times \underbrace{(1 - \text{CV}_{time}^{ij})}_{\text{Stabilityï¼ˆç¨³å®šæ€§ï¼‰}} \times \underbrace{\left(1 + \alpha \cdot \frac{N_{FR}^{ij}}{N_{total}^{ij}}\right)}_{\text{Pathologyï¼ˆç—…ç†æ€§ï¼‰}}$$

| ç»´åº¦ | å®šä¹‰ | æ•°æ®æ¥æº | Phase |
|------|------|----------|-------|
| **Causality** | $\text{Simpson}_{ij} \times \text{Consistency}_{ij}$ â€” Simpson å½’ä¸€åŒ–å…±æ¿€æ´» Ã— æ–¹å‘ä¸€è‡´æ€§ | `W_pruned` + `lag_raw` | **A (ç«‹å³å¯åš)** |
| **Stability** | $1 - \text{CV}(\text{Connectivity}(t))$ â€” è¿æ¥çš„æ—¶é—´é²æ£’æ€§ | `event_windows` æŒ‰æ—¶é—´çª—åˆ‡ç‰‡ | **A (ç«‹å³å¯åš)** |
| **Pathology** | $1 + \alpha \cdot \frac{N_{FR}}{N_{total}}$ â€” Fast Ripple æ¯”ä¾‹åŠ æƒ | `hfo_type_per_event` | **B (éœ€åˆ†ç±»æ•°æ®)** |

##### 4.5.2 Stabilityï¼ˆç¨³å®šæ€§ï¼‰ç»´åº¦ â€” æ—¶é—´é²æ£’æ€§

**æ ¸å¿ƒæ€æƒ³**ï¼šç™«ç—«ç½‘ç»œåº”å…·æœ‰åˆ»æ¿æ€§ï¼ˆStereotypicalï¼‰ï¼Œéšæœºå‡ºç°çš„è¿æ¥æ˜¯å™ªå£°ã€‚

```python
def compute_stability_weights(
    lag_raw: np.ndarray,           # (n_ch, n_events) è´¨å¿ƒæ—¶é—´
    events_bool: np.ndarray,       # (n_ch, n_events) å‚ä¸mask
    event_times: np.ndarray,       # (n_events,) äº‹ä»¶æ—¶é—´æˆ³
    window_sec: float = 300.0,     # 5åˆ†é’Ÿæ—¶é—´çª—
    min_windows: int = 3,          # æœ€å°‘çª—å£æ•°
) -> np.ndarray:
    """
    è®¡ç®—æ¯æ¡è¾¹åœ¨å¤šä¸ªæ—¶é—´çª—å†…çš„è¿æ¥æ–¹å‘ä¸€è‡´æ€§ã€‚
    
    Stability = 1 - CV(consistency_per_window)
    é«˜ç¨³å®šæ€§ = å›ºå®šçš„ç—…ç†é€šè·¯ï¼›ä½ç¨³å®šæ€§ = ç¬æ€å™ªå£°
    """
    n_ch = lag_raw.shape[0]
    stability = np.full((n_ch, n_ch), np.nan)
    
    # æŒ‰æ—¶é—´çª—åˆ‡ç‰‡
    t_min, t_max = event_times.min(), event_times.max()
    edges = np.arange(t_min, t_max, window_sec)
    if len(edges) < min_windows:
        return np.ones((n_ch, n_ch))  # æ•°æ®ä¸å¤Ÿï¼Œé€€åŒ–ä¸ºæƒé‡1
    
    window_consistencies = []
    for t_start in edges:
        t_end = t_start + window_sec
        win_mask = (event_times >= t_start) & (event_times < t_end)
        if win_mask.sum() < 5:
            continue
        
        # æ¯ä¸ªæ—¶é—´çª—å†…è®¡ç®—æ–¹å‘ä¸€è‡´æ€§
        cons = np.zeros((n_ch, n_ch))
        for i in range(n_ch):
            for j in range(i+1, n_ch):
                both = events_bool[i, win_mask] & events_bool[j, win_mask]
                if both.sum() < 3:
                    continue
                lags = lag_raw[i, win_mask][both] - lag_raw[j, win_mask][both]
                med = np.median(lags)
                cons[i, j] = np.mean(np.sign(lags) == np.sign(med))
                cons[j, i] = cons[i, j]
        window_consistencies.append(cons)
    
    if len(window_consistencies) < min_windows:
        return np.ones((n_ch, n_ch))
    
    stacked = np.stack(window_consistencies)
    mean_cons = np.nanmean(stacked, axis=0)
    std_cons = np.nanstd(stacked, axis=0)
    cv = np.where(mean_cons > 0, std_cons / mean_cons, 1.0)
    stability = 1.0 - np.clip(cv, 0, 1)
    
    return stability
```

##### 4.5.3 Pathologyï¼ˆç—…ç†æ€§ï¼‰ç»´åº¦ â€” é¢‘ç‡ç‰¹å¼‚æ€§

**è®¾è®¡ç†ç”±**ï¼ˆå‚è€ƒæ–‡çŒ®ï¼šSpikewHFOæ›´é‡è¦.pdfï¼‰ï¼š
- å åŠ  HFO çš„ Spike æ¯”å•çº¯ Spike æ›´èƒ½å®šä½ SOZ
- Fast Ripple æ¯” Ripple æ›´å…·ç—…ç†ç‰¹å¼‚æ€§
- ç»™é«˜ç—…ç†æ€§ä¼ æ’­äº‹ä»¶æ›´é«˜æŠ•ç¥¨æƒ

**Phase Aï¼ˆç«‹å³å¯åšï¼‰**ï¼šç”¨ Coact Ã— Consistency Ã— Stability ä¸‰ç»´æƒé‡

**Phase Bï¼ˆéœ€ FR åˆ†ç±»æ•°æ®åï¼‰**ï¼šåŠ å…¥ $(1 + \alpha \cdot FR_{ratio})$ å› å­ï¼Œ$\alpha$ å»ºè®® 0.5-2.0

##### 4.5.4 è¿›é˜¶æ–¹å‘ï¼šé¢‘è°±å› æœæ€§ï¼ˆPhase C ç ”ç©¶å‰æ²¿ï¼‰

> ç”¨é¢‘è°±æ ¼å…°æ°å› æœ (Spectral GC) æˆ–åå®šå‘ç›¸å¹² (PDC) æ›¿ä»£ Lag-based å› æœæ¨æ–­ã€‚

$$W_{ij}^{advanced} = \underbrace{\text{PDC}_{ij}(f_{HFO})}_{\text{é¢‘åŸŸå› æœ}} \times \underbrace{(1 - \text{CV}_{time})}_{\text{ç¨³å®šæ€§}} \times \underbrace{\frac{SC_{ij}}{SC_{max}}}_{\text{è§£å‰–å…ˆéªŒ}} \times \underbrace{\text{PathScore}_i}_{\text{èŠ‚ç‚¹ç—…ç†åˆ†}}$$

**ä¸ºä»€ä¹ˆåˆ—ä¸º Phase C**ï¼šPDC éœ€è¦æ¨¡å‹é˜¶æ•°é€‰æ‹©ï¼ˆAIC/BICï¼‰ã€å¹³ç¨³æ€§æ£€éªŒã€$O(N^2 \times T \times p)$ è®¡ç®—ã€‚å¯¹ 50 é€šé“ Ã— 2h æ•°æ®è™½ç„¶å¯è¡Œä½†è°ƒå‚å¤æ‚ã€‚å…ˆç”¨ Lag-based æ–¹æ³•éªŒè¯æ•´ä½“æµç¨‹ï¼Œå†è€ƒè™‘æ›¿æ¢ä¸º PDCã€‚

---

#### 4.6 å›¾è®ºæŒ‡æ ‡è®¡ç®— (Metric Calculation)

**ä½¿ç”¨ `networkx` åº“**ï¼š

| æŒ‡æ ‡ | å…¬å¼ | ä¸´åºŠæ„ä¹‰ |
|------|------|---------|
| **Net Outflow Index** | $\frac{OutDegree - InDegree}{OutDegree + InDegree}$ | **SOZ å®šä½**ï¼šå€¼æ¥è¿‘ +1 = Source |
| **Outflow Volatility** | $\text{Var}(\text{NetOutflow}_t)$ | çœŸæ­£ SOZ å¾€å¾€å‘ä½œå‰çªç„¶çˆ†å‘ |
| **Local Efficiency** | $E_{loc}(i) = \frac{1}{k_i(k_i-1)} \sum_{j,h \in N_i} \frac{1}{d_{jh}}$ | è‡´ç—«ç¶çš„ç´§å¯†ç¨‹åº¦ |
| **Shortest Path Tree** | ä» Source å‡ºå‘çš„æœ€çŸ­è·¯å¾„ | ä¼ æ’­è·¯å¾„é¢„æµ‹ |

```python
import networkx as nx

def compute_network_metrics(adj: np.ndarray, ch_names: List[str]) -> Dict:
    """
    è®¡ç®—æ ¸å¿ƒå›¾è®ºæŒ‡æ ‡ã€‚
    """
    G = nx.DiGraph()
    n = adj.shape[0]
    
    for i in range(n):
        for j in range(n):
            if adj[i, j] > 0:
                G.add_edge(ch_names[i], ch_names[j], weight=adj[i, j])
    
    metrics = {}
    
    # Net Outflow Index
    for node in G.nodes():
        out_deg = G.out_degree(node, weight='weight')
        in_deg = G.in_degree(node, weight='weight')
        total = out_deg + in_deg
        metrics[f'{node}_outflow'] = (out_deg - in_deg) / total if total > 0 else 0
    
    # Local Efficiency (éœ€è¦è½¬æ— å‘å›¾)
    G_undirected = G.to_undirected()
    metrics['local_efficiency'] = nx.local_efficiency(G_undirected)
    
    # Betweenness Centrality
    metrics['betweenness'] = nx.betweenness_centrality(G, weight='weight')
    
    return metrics
```

---

#### 4.7 å…³é”®é™·é˜±ä¸é˜²æŠ¤ (Critical Pitfalls)

**é™·é˜±1ï¼šå®¹ç§¯ä¼ å¯¼çš„å¹½çµ (Volume Conduction)**

| ç°è±¡ | ç‰©ç†è·ç¦» <10mmï¼ŒLag â‰ˆ 0ï¼ŒCo-activation æé«˜ |
|------|-------------------------------------------|
| åŸå›  | ç”µåœºç›´æ¥ä¼ å¯¼ï¼Œéç¥ç»å…ƒä¼ æ’­ |
| å±å®³ | ç½‘ç»œè¢«æ— æ„ä¹‰çŸ­è¾¹ä¸»å¯¼ |
| **é˜²æŠ¤** | å¼ºåˆ¶å‰”é™¤ `dist_matrix < 10mm` çš„è¾¹ |
| **åå‘åˆ©ç”¨** | ä¿ç•™å±€éƒ¨è¿æ¥å¼ºåº¦ä½œä¸º "Local Recruitment Score" |
| **é›¶æ»åé™·é˜±** | æ·±éƒ¨å¼ºæºè¢«ä¸¤ä¸ªè¿œè·ç”µæåŒæ—¶è®°å½• â†’ é«˜åŒæ­¥ä½†é›¶å»¶è¿Ÿ<br>å¿…é¡»ç”¨ PLI/wPLIï¼ˆå¯¹é›¶æ»åä¸æ•æ„Ÿï¼‰æˆ– Wilcoxon æ£€éªŒè¿‡æ»¤ |

**é™·é˜±2ï¼šé‡‡æ ·åå·® (Sampling Bias)**

| ç°è±¡ | SEEG ä»…è¦†ç›–ä¸åˆ° 1% çš„è„‘ä½“ç§¯ |
|------|------------------------------|
| å±å®³ | çœŸæ­£çš„æºåœ¨æœªé‡‡æ ·åŒºï¼Œä¸­ç»§ç«™è¢«è¯¯åˆ¤ä¸ºæº |
| **é˜²æŠ¤** | ç»“è®ºå¿…é¡»è°¨æ…ï¼š<br>"åœ¨è¢«ç›‘æµ‹çš„ç½‘ç»œä¸­ï¼ŒèŠ‚ç‚¹ X è¡¨ç°å‡ºæºçš„ç‰¹å¾" |

**é™·é˜±3ï¼šä¸­ä½æ•°é™·é˜± (The Median Trap)**

| ç°è±¡ | Lag åˆ†å¸ƒå¤šå³°ï¼ˆç›´æ¥é€šè·¯ 5ms + é—´æ¥é€šè·¯ 25msï¼‰ |
|------|-------------------------------------------|
| å±å®³ | ä¸­ä½æ•° 15ms åœ¨ç‰©ç†ä¸Šä¸å­˜åœ¨ |
| **é˜²æŠ¤** | å•å³°æ€§æ£€éªŒ (Hartigan's dip test) æˆ–æ–¹å·®æ£€æŸ¥<br>é«˜æ–¹å·®è¾¹æ ‡è®°ä¸º "Unstable Connection"ï¼Œé™ä½æƒé‡ |

**é™·é˜±4ï¼šé™æ€ç½‘ç»œçš„å±€é™**

| ç°è±¡ | 24å°æ—¶å¹³å‡å›¾æŠ¹æ€æ—¶é—´ç»´åº¦ |
|------|-------------------------|
| å±å®³ | é—´æ­‡æ€§å–·å‘çš„ SOZ è¢«æŒç»­æ´»è·ƒçš„ä¸­ç»§ç«™æ©ç›– |
| **è¿›é˜¶æ–¹å‘** | åŠ¨æ€åˆ‡ç‰‡ï¼šæ¯ 5 åˆ†é’Ÿæˆ–æ¯ 100 äº‹ä»¶è®¡ç®—ä¸€æ¬¡<br>æ¯”è¾ƒ Pre-ictal vs Interictal ç½‘ç»œæ‹“æ‰‘ |

**é™·é˜±5ï¼šç”Ÿç†æ€§ HFO æ··æ·† (Physiological HFO Contamination)** ğŸ”´ æ–°å¢

| ç°è±¡ | è§†è§‰/è¿åŠ¨çš®å±‚å’Œæµ·é©¬åœ¨ NREM æœŸé—´äº§ç”Ÿé«˜å‘æ”¾ç‡ç”Ÿç†æ€§ HFO |
|------|--------------------------------------------------|
| å±å®³ | åŠŸèƒ½åŒºè¢«è¯¯åˆ¤ä¸ºè‡´ç—«ç¶ â†’ æ‰‹æœ¯å¯¼è‡´åŠŸèƒ½ç¼ºæŸ |
| **é˜²æŠ¤** | è°±èšç±» + å…±æ¿€æ´»è¿‡æ»¤ â€” ç”Ÿç†æ€§ HFO å¾€å¾€æ˜¯å­¤ç«‹çš„å±€éƒ¨åŠŸèƒ½æŸ±æ´»åŠ¨ï¼Œä¸å½¢æˆå¤§å°ºåº¦åŒæ­¥ç½‘ç»œ<br>Stability æƒé‡ â€” ç”Ÿç†æ€§ HFO æ˜¯ä»»åŠ¡/çŠ¶æ€ç›¸å…³çš„ç¬æ€ï¼Œç—…ç†æ€§æ›´æŒç»­ |
| **è¡¥å……** | ç»“åˆ Spike-HFO å…±ç°ç‰¹å¾ï¼šå åŠ  Spike çš„ HFO ç—…ç†ç‰¹å¼‚æ€§æ›´é«˜ |

**é™·é˜±6ï¼šSink/Source åè½¬ (Sink Trap)** ğŸ”´ æ–°å¢

| ç°è±¡ | SOZ åœ¨å‘ä½œé—´æœŸå¯èƒ½è¡¨ç°ä¸º Sinkï¼ˆè¢«æŠ‘åˆ¶ï¼‰ï¼Œå‘ä½œæœŸè½¬ä¸º Source |
|------|------------------------------------------------------|
| å±å®³ | ä»…åˆ†æå‘ä½œé—´æœŸæ•°æ®ä¼šå°† SOZ è¯¯åˆ¤ä¸º"æ¥æ”¶èŠ‚ç‚¹" |
| **é˜²æŠ¤** | å¿…é¡»ç»“åˆ Ictal æ•°æ®éªŒè¯ï¼šå¯»æ‰¾"é—´æœŸ Sink â†’ å‘ä½œæœŸ Source"çš„åŠ¨æ€åè½¬èŠ‚ç‚¹<br>è¿™ç§åè½¬æœ¬èº«å°±æ˜¯ EZ çš„"æŒ‡çº¹"ç‰¹å¾ |
| **æŒ‡æ ‡** | $\Delta \text{Outflow} = \text{Outflow}_{ictal} - \text{Outflow}_{interictal}$ â€” åè½¬å¹…åº¦æœ€å¤§çš„èŠ‚ç‚¹ |

**é™·é˜±7ï¼šSEEG è¡Œæ³¢å‡è®¾å¤±æ•ˆ (Traveling Wave Caveat)** ğŸ”´ æ–°å¢

| ç°è±¡ | HFO/IED åœ¨çš®å±‚ä¸Šè¡¨ç°ä¸ºè¡Œæ³¢ï¼ˆTraveling Wavesï¼‰ |
|------|---------------------------------------------|
| å±å®³ | åœ¨ Grid ç”µæä¸Šå¯ç›´æ¥æ‹Ÿåˆæ³¢å³°æ¢¯åº¦åœºè®¡ç®—ä¼ æ’­é€Ÿåº¦çŸ¢é‡<br>**ä½† SEEG æ˜¯æ£’çŠ¶æ·±éƒ¨ç”µæ**ï¼Œç©¿è¿‡ä¸åŒçš®å±‚å±‚çº§ï¼Œ2D å¹³é¢æ³¢å‡è®¾å¤±æ•ˆ |
| **é˜²æŠ¤** | åœ¨ SEEG ä¸­å¿…é¡»æ²¿ç”µæè½´å‘ï¼ˆAxialï¼‰å’Œè·¨ç”µæï¼ˆCross-electrodeï¼‰åˆ†åˆ«è®¡ç®—å»¶è¿Ÿ<br>ä¸å¯ç›²ç›®æ‹Ÿåˆå¹³é¢æ³¢ |
| **æ–¹å‘åè½¬** | IED ä¼ æ’­æ–¹å‘é€šå¸¸**æŒ‡å‘**è‡´ç—«ç¶ï¼ˆSink ç‰¹å¾ï¼‰<br>Ictal Discharge é€šå¸¸**èƒŒç¦»**è‡´ç—«ç¶ä¼ æ’­<br>è¿™ä¸€æ–¹å‘åè½¬æ˜¯é‡è¦çš„å®šä½ç‰¹å¾ |

---

#### 4.8 ä¸‰é˜¶æ®µå®æ–½è·¯çº¿å›¾ (Three-Phase Roadmap)

> "Theory and practice sometimes clash. Theory loses. Every single time." â€” å…ˆç”¨ç°æœ‰æ•°æ®è·‘é€šå…¨æµç¨‹ï¼Œå†é€æ­¥åŠ å…¥é«˜çº§ç‰¹å¾ã€‚

##### Phase Aï¼šChannel-Scale MVPï¼ˆæ•°æ®å·²å°±ç»ªï¼Œç«‹å³å¯åšï¼‰

| Step | ä»»åŠ¡ | è¾“å…¥ | è¾“å‡º | æ–°å¢ä¾èµ– | çŠ¶æ€ |
|------|------|------|------|----------|------|
| A.1 | **å®½å»ºå›¾ (Simpson Index)** | `coact_all_event_count` | `W_broad` (n_all, n_all) | â€” | â¬œ |
| A.2 | æ›¿ä»£æ•°æ®æ˜¾è‘—æ€§æ£€éªŒ | `events_bool` | `sig_mask` | â€” | â¬œ |
| A.3 | **XYZ ç‰¹å¾è®¡ç®—** | `W_broad`, `events_count`, `duration` | `X, Y, Z` per node | â€” | â¬œ |
| A.4 | **XYZ å¤šç»´å‰ªæ** | `W_broad`, `X`, `Y`, `Z` | `selected_idx`, `W_pruned` | `sklearn` (è°±èšç±») | â¬œ |
| A.5 | æ–¹å‘æ³¨å…¥ï¼ˆWilcoxon+ä¸€è‡´æ€§ï¼‰ | `W_pruned`, `lag_raw` | `adj_directed` | `scipy.stats` | â¬œ |
| A.6 | Stability æƒé‡ | `lag_raw`, `event_windows` | `stability_matrix` | â€” | â¬œ |
| A.7 | å¤åˆæƒé‡è®¡ç®— | `adj`, `W_pruned`, `stability` | `adj_weighted` | â€” | â¬œ |
| A.8 | å›¾è®ºæŒ‡æ ‡ | `adj_weighted` | `metrics_dict` | `networkx` | â¬œ |
| A.9 | 2D ç½‘ç»œæ‹“æ‰‘å›¾ + XY æ•£ç‚¹è¯Šæ–­å›¾ | `metrics`, `X`, `Y` | `network_plot.png` | `matplotlib` | â¬œ |

**Phase A çš„äº¤ä»˜ç‰©**ï¼š
1. ä¸€ä¸ªå®Œæ•´çš„ Channel-scale æœ‰å‘åŠ æƒç™«ç—«ç½‘ç»œï¼ˆSimpson å½’ä¸€åŒ– + XYZ å‰ªæï¼‰
2. XY æ•£ç‚¹è¯Šæ–­å›¾ï¼šç›´è§‚å±•ç¤ºå“ªäº›èŠ‚ç‚¹è¢«ä¿ç•™/å‰”é™¤åŠåŸå› 
3. Net Outflow æ’åï¼ˆSource-Sink é¢„æµ‹ï¼‰

##### Phase Bï¼šChannel-Scale + Geometryï¼ˆéœ€ MNI åæ ‡ï¼‰

| Step | ä»»åŠ¡ | è¾“å…¥ | è¾“å‡º | é˜»å¡æ¡ä»¶ | çŠ¶æ€ |
|------|------|------|------|----------|------|
| B.0 | ç”µæåæ ‡è·å– | MNI é…å‡†ç»“æœ | `mni_coords.npy`, `dist_matrix.npy` | **éœ€ä¸´åºŠæ•°æ®** | â¬œ |
| B.1 | ç©ºé—´çº¦æŸéª¨æ¶ | `dist_matrix`, `coact_ratio` | `skeleton_spatial` | B.0 | â¬œ |
| B.2 | å®¹ç§¯ä¼ å¯¼å‰”é™¤ | `dist_matrix < 10mm` | `skeleton_clean` | B.0 | â¬œ |
| B.3 | ä¼ æ’­é€Ÿåº¦éªŒè¯ | `dist_matrix`, `lag_raw` | `velocity_map` (0.1-10 m/s) | B.0 | â¬œ |
| B.4 | ç—…ç†åŠ æƒï¼ˆFR æ¯”ä¾‹ï¼‰ | `hfo_type_per_event` | `pathology_weight` | **éœ€ FR åˆ†ç±»** | â¬œ |
| B.5 | 3D è„‘å›¾ | `metrics`, `mni_coords` | `outflow_brain_3d.html` | B.0 | â¬œ |
| B.6 | Ictal vs Interictal å¯¹æ¯” | `event_windows`, `seizure_onsets` | `delta_outflow` | â€” | â¬œ |

**Phase B çš„äº¤ä»˜ç‰©**ï¼šç‰©ç†çº¦æŸåçš„ç½‘ç»œ + 3D å¯è§†åŒ– + Sink/Source åè½¬åˆ†æã€‚

##### Phase Cï¼šSource-Scale ç ”ç©¶å‰æ²¿ï¼ˆéœ€å½±åƒå­¦æµæ°´çº¿ï¼‰

| Step | ä»»åŠ¡ | è¾“å…¥ | é˜»å¡æ¡ä»¶ | çŠ¶æ€ |
|------|------|------|----------|------|
| C.1 | å‰å‘æ¨¡å‹(BEM) | FreeSurfer è¾“å‡º, ç”µæåæ ‡ | éœ€ MRI åˆ†å‰² + é…å‡† | â¬œ |
| C.2 | å¯¼è”åœºçŸ©é˜µ(LFM) | BEM æ¨¡å‹ | C.1 | â¬œ |
| C.3 | LFM æ¦‚ç‡æŠ•å½± | `LFM`, `channel_metrics` | C.2 | â¬œ |
| C.4 | SC-FC è€¦åˆå›¾ | HCP tractography | éœ€ DWI æ•°æ® | â¬œ |
| C.5 | PDC/é¢‘è°±æ ¼å…°æ° | åŸå§‹æ—¶é—´åºåˆ— | è®¡ç®—å¯†é›† | â¬œ |
| C.6 | NMM éªŒè¯ | è¿æ¥çŸ©é˜µ | ç‹¬ç«‹ç ”ç©¶è¯¾é¢˜ | â¬œ |

**Phase C çš„äº¤ä»˜ç‰©**ï¼šæºç©ºé—´çº§åˆ«çš„ç—…ç†ç½‘ç»œé‡æ„ï¼ˆç ”ç©¶è®ºæ–‡çº§åˆ«ï¼‰ã€‚

---

**æ ¸å¿ƒ API è®¾è®¡**ï¼š

```python
# src/network_analysis.py

@dataclass
class NetworkResult:
    """ç™«ç—«ç½‘ç»œåˆ†æç»“æœ (v2: Build-Prune-Direct)."""
    adj: np.ndarray              # (n_sel, n_sel) æœ‰å‘åŠ æƒé‚»æ¥çŸ©é˜µ
    node_names: List[str]        # èŠ‚ç‚¹é€šé“å
    node_xyz: Dict[str, np.ndarray]  # {'X': rate, 'Y': entropy, 'Z': epileptogenicity}
    W_broad: np.ndarray          # (n_all, n_all) Simpson å®½å»ºå›¾ï¼ˆå¯å›æº¯ï¼‰
    W_pruned: np.ndarray         # (n_sel, n_sel) å‰ªæåå­å›¾
    metrics: Dict[str, Any]      # å›¾è®ºæŒ‡æ ‡
    edge_stats: List[Dict]       # æ¯æ¡è¾¹çš„ç»Ÿè®¡ä¿¡æ¯
    cluster_labels: np.ndarray   # (n_all,) è°±èšç±»æ ‡ç­¾ (-1=å‰”é™¤)

def build_hfo_network(
    group_analysis_npz: str,
    dist_matrix: Optional[np.ndarray] = None,
    *,
    # â€” Step 1: å®½å»ºå›¾ â€”
    edge_method: str = 'simpson',     # 'simpson' | 'dice'
    run_surrogate: bool = True,
    n_surrogates: int = 200,
    # â€” Step 2: XYZ å‰ªæ â€”
    min_rate: float = 0.5,            # X: æœ€ä½ HFO Rate (events/min)
    max_entropy: float = 0.85,        # Y: æœ€é«˜å½’ä¸€åŒ–è¿æ¥ç†µ
    use_spectral: bool = True,        # Z: è°±èšç±»è¿›ä¸€æ­¥å‰ªæ
    min_cluster_size: int = 3,
    n_clusters: Optional[int] = None, # None = Eigengap è‡ªåŠ¨
    # â€” Step 3: æ–¹å‘æ³¨å…¥ â€”
    min_events: int = 5,
    lag_thresh_ms: float = 5.0,
    consistency_thresh: float = 0.6,
    p_value_thresh: float = 0.05,
    # â€” Step 4: ç¨³å®šæ€§ â€”
    stability_window_sec: float = 300.0,
) -> NetworkResult:
    """
    ä¸€ç«™å¼æ„å»ºç™«ç—«ç½‘ç»œ v2ï¼ˆPhase A: Channel-Scaleï¼‰ã€‚

    æµç¨‹ï¼šSimpson å®½å»ºå›¾ â†’ XYZ å¤šç»´å‰ªæ â†’ æ–¹å‘æ³¨å…¥ â†’ å¤åˆæƒé‡ â†’ å›¾è®ºæŒ‡æ ‡

    Returns
    -------
    NetworkResult : åŒ…å«æœ‰å‘åŠ æƒé‚»æ¥çŸ©é˜µã€XYZ ç‰¹å¾å’Œå›¾è®ºæŒ‡æ ‡
    """
    ...
```

**å¯è§†åŒ–ç»ˆæç›®æ ‡**ï¼š

```python
def plot_outflow_brain_map(
    network_result: NetworkResult,
    mni_coords: np.ndarray,
    output_path: str,
):
    """
    3D è„‘å›¾ï¼ˆPhase B äº¤ä»˜ç‰©ï¼‰ï¼š
    - èŠ‚ç‚¹é¢œè‰² = Net Outflow (çº¢=Source, è“=Sink)
    - èŠ‚ç‚¹å¤§å° = Local Efficiency
    - è¾¹é¢œè‰² = ä¼ æ’­æ–¹å‘
    - è¾¹ç²—ç»† = æƒé‡

    è¿™æ˜¯ç›´æ¥å¯¹è¯ä¸´åºŠåŒ»ç”Ÿçš„"ç»ˆæå›¾è¡¨"ã€‚
    """
    ...

def plot_network_topology_2d(
    network_result: NetworkResult,
    output_path: str,
    layout: str = 'spring',
):
    """
    2D ç½‘ç»œæ‹“æ‰‘å›¾ï¼ˆPhase A äº¤ä»˜ç‰©ï¼‰ï¼š
    - èŠ‚ç‚¹é¢œè‰² = Net Outflow
    - èŠ‚ç‚¹å¤§å° = Node Weight (EigenCentrality Ã— Rate)
    - è¾¹ç²—ç»† = å¤åˆæƒé‡
    - å¸ƒå±€ = spring / circular / spectral

    ä¸éœ€è¦ MNI åæ ‡ï¼ŒPhase A å³å¯ç”Ÿæˆã€‚
    """
    ...
```

---

#### 4.9 åŠŸèƒ½æ¸…å• (Feature Checklist)

**Phase A â€” Channel-Scale MVPï¼ˆç«‹å³å¯åšï¼‰**

| åŠŸèƒ½ | è¯´æ˜ | ä¾èµ– | çŠ¶æ€ |
|------|------|------|------|
| A.1 å®½å»ºå›¾ (Simpson) | Simpson Index å½’ä¸€åŒ–å…±æ¿€æ´» â†’ å®½è¾¹æƒå›¾ | `coact_all_event_count` | â¬œ |
| A.2 æ›¿ä»£æ•°æ®æ£€éªŒ | Surrogate test éªŒè¯å…±æ¿€æ´»æ˜¾è‘—æ€§ | `events_bool` | â¬œ |
| A.3 XYZ ç‰¹å¾è®¡ç®— | X=Rate, Y=Connection Entropy, Z=placeholder | `W_broad` | â¬œ |
| A.4 XYZ å¤šç»´å‰ªæ | Xé—¨æ§ + Yé—¨æ§ + è°±èšç±»(XYè·ç¦») | `sklearn` | â¬œ |
| A.5 æ–¹å‘æ³¨å…¥ | Wilcoxon + ä¸€è‡´æ€§ + é›¶æ»åè¿‡æ»¤ | `lag_raw`, `scipy.stats` | â¬œ |
| A.6 Stability æƒé‡ | æ—¶é—´çª—åˆ‡ç‰‡ + CV è®¡ç®— | `event_windows` | â¬œ |
| A.7 å¤åˆæƒé‡ | Simpson Ã— Consistency Ã— Stability | â€” | â¬œ |
| A.8 å›¾è®ºæŒ‡æ ‡ | Net Outflow, Local Efficiency, Betweenness | `networkx` | â¬œ |
| A.9 2D ç½‘ç»œæ‹“æ‰‘å›¾ | Spring å¸ƒå±€ + XY æ•£ç‚¹è¯Šæ–­å›¾ | `matplotlib` | â¬œ |
| A.10 ä¼ æ’­è·¯å¾„ | æœ€çŸ­è·¯å¾„æ ‘ | `adj` | â¬œ |

**Phase B â€” Channel + Geometryï¼ˆéœ€ MNI åæ ‡ï¼‰**

| åŠŸèƒ½ | è¯´æ˜ | é˜»å¡æ¡ä»¶ | çŠ¶æ€ |
|------|------|----------|------|
| B.1 ç©ºé—´çº¦æŸéª¨æ¶ | è·ç¦»æƒ©ç½š + å®¹ç§¯ä¼ å¯¼å‰”é™¤ | MNI coords | â¬œ |
| B.2 ä¼ æ’­é€Ÿåº¦éªŒè¯ | 0.1-10 m/s ç”Ÿç†èŒƒå›´æ£€æŸ¥ | MNI coords | â¬œ |
| B.3 ç—…ç†åŠ æƒ | FR æ¯”ä¾‹åŠ æƒ | HFO type åˆ†ç±» | â¬œ |
| B.4 3D è„‘å›¾ | Outflow é¢œè‰²æ˜ å°„ | MNI coords | â¬œ |
| B.5 åŠ¨æ€åˆ‡ç‰‡ | Pre-ictal vs Interictal ç½‘ç»œå¯¹æ¯” | Seizure onsets | â¬œ |
| B.6 Sink/Source åè½¬ | $\Delta$Outflow (ictal - interictal) | B.5 | â¬œ |

**Phase C â€” Source Space ç ”ç©¶å‰æ²¿**

| åŠŸèƒ½ | è¯´æ˜ | é˜»å¡æ¡ä»¶ | çŠ¶æ€ |
|------|------|----------|------|
| C.1 å‰å‘æ¨¡å‹(BEM/FEM) | æ‚£è€…ä¸ªæ€§åŒ–å¯¼è”åœº | FreeSurfer + MRI | â¬œ |
| C.2 LFM æ¦‚ç‡æŠ•å½± | çµæ•åº¦åŠ æƒæ˜ å°„ | C.1 | â¬œ |
| C.3 SC-FC è€¦åˆå›¾ | è§£å‰–å…ˆéªŒçº¦æŸ | HCP tractography | â¬œ |
| C.4 PDC/é¢‘è°±æ ¼å…°æ° | é¢‘åŸŸå› æœæ€§ | æ¨¡å‹é˜¶æ•°é€‰æ‹© | â¬œ |
| C.5 NMM éªŒè¯ | åˆ†æ-ç»¼åˆé—­ç¯ | ç‹¬ç«‹ç ”ç©¶è¯¾é¢˜ | â¬œ |

---

#### 4.10 æºç©ºé—´æ„å»ºè¿œæ™¯ (Source Space Vision) â€” Phase C ç†è®ºåŸºç¡€

> æœ¬èŠ‚è®°å½• Source-Scale ç½‘ç»œæ„å»ºçš„ç†è®ºåŸºç¡€å’Œå·¥ç¨‹è·¯å¾„ã€‚**å½“å‰ä¸å®ç°**ï¼Œä½œä¸ºç ”ç©¶å‰æ²¿å‚è€ƒã€‚

##### 4.10.1 ç²’åº¦å›°å¢ƒ (Granularity Dilemma)

| å°ºåº¦ | åˆ†è¾¨ç‡ | å¤±æ•ˆåŸå›  |
|------|--------|---------|
| **è„‘åŒº (AAL/DK)** | ~100 åŒºåŸŸ | HFO ç”Ÿæˆå™¨ <2mmï¼Œè„‘åŒºå¹³å‡åŒ–å½»åº•æ·¹æ²¡ç—…ç†ä¿¡å·ï¼ŒSNR æŒ‡æ•°ä¸‹é™ |
| **é¡¶ç‚¹ (Vertex)** | ~20k/åŠçƒ | SEEG ä»… 100-200 è§¦ç‚¹ â†’ æåº¦æ¬ å®šé€†é—®é¢˜ â†’ æ— æ•°æ®åŒºåŸŸçš„"æ’å€¼å¹»è§‰" |
| **ä¼ æ„Ÿä½“ç§¯ (VOI)** | **5mm åŠå¾„** | âœ… åŒ¹é… SEEG å®ç”µæä¼ æ„ŸåŠå¾„ (~3-5mm)<br>âœ… åŒ…å« HFO å¾®è§‚å‘ç”Ÿç»“æ„<br>âœ… é¿å…è¿‡åº¦æ’å€¼ |

**ç»“è®º**ï¼šæºç©ºé—´èŠ‚ç‚¹åº”å®šä¹‰ä¸ºä»¥ç”µæè§¦ç‚¹ä¸ºä¸­å¿ƒçš„ 5mm VOIï¼ˆVirtual Voxelsï¼‰ï¼Œéå‡åŒ€å…¨è„‘ç½‘æ ¼ã€‚

##### 4.10.2 LFM æ¦‚ç‡æŠ•å½± (Lead-Field Weighted Projection)

> æ— éœ€æ±‚è§£å¤æ‚çš„æºæˆåƒé€†é—®é¢˜ã€‚åˆ©ç”¨å¯¼è”åœºçŸ©é˜µä½œä¸ºå‡ ä½•å…ˆéªŒè¿›è¡Œæ¦‚ç‡æ˜ å°„ã€‚

**æ ¸å¿ƒå…¬å¼**ï¼š

$$W_{ji} = \frac{L_{ij}^2}{\sum_{k \in \text{Channels}} L_{kj}^2}$$

$$\text{SourceMetric}_j = \sum_{i} W_{ji} \cdot \text{ChannelMetric}_i$$

å…¶ä¸­ $L_{ij}$ æ˜¯å¯¼è”åœºçŸ©é˜µä¸­æº $j$ å¯¹é€šé“ $i$ çš„è´¡çŒ®ï¼ˆåŒ…å«è·ç¦»è¡°å‡å’Œå¶æå­æ–¹å‘ä¿¡æ¯ï¼‰ã€‚ä½¿ç”¨å¹³æ–¹æ˜¯å› ä¸ºåŠŸç‡/èƒ½é‡éšè·ç¦»å¹³æ–¹è¡°å‡ã€‚

**ä¼˜åŠ¿**ï¼š
- è®¡ç®—é«˜æ•ˆï¼šä¸€æ¬¡æ€§çº¿æ€§å˜æ¢ï¼Œéè¿­ä»£åæ¼”
- ç‰©ç†åˆç†ï¼šè‡ªåŠ¨å¤„ç†è·ç¦»åŠ æƒ + æ–¹å‘æ€§
- é¿å… Double Countingï¼šå½’ä¸€åŒ–æƒé‡è‡ªç„¶åˆ†é…é‡å åŒºåŸŸ

**å¯¹å…±æ¿€æ´»çŸ©é˜µçš„æ˜ å°„æ‰©å±•**ï¼š

$$\text{SourceCoAct}_{jk} = \sum_{m,n} W_{jm} \cdot \text{ChannelCoAct}_{mn} \cdot W_{kn}$$

##### 4.10.3 SC-FC è€¦åˆå›¾ (Structure-Function Coupled Graph)

> åœ¨æºç©ºé—´å®šä¹‰ä¼ æ’­è·¯å¾„æ—¶ï¼Œå¿…é¡»å¼•å…¥ HCP SC ä½œä¸ºè´å¶æ–¯å…ˆéªŒã€‚

$$P(E_{A \to B} | \text{Data}) \propto \text{FC}_{A \to B} \times \text{SC}_{A \to B}$$

**ç‰©ç†æ„ä¹‰**ï¼šå¦‚æœæº A åˆ°æº B çš„åŠŸèƒ½è¿æ¥ï¼ˆFCï¼‰å¾ˆå¼ºï¼Œä½†æ— ç™½è´¨çº¤ç»´æŸç›´æ¥è¿æ¥ï¼ˆSC â‰ˆ 0ï¼‰ï¼Œåˆ™è¯¥"è¿æ¥"æå¯èƒ½æ˜¯é—´æ¥çš„æˆ–è™šå‡çš„ã€‚

**å·¥ç¨‹ä¾èµ–é“¾**ï¼š
1. FreeSurfer çš®å±‚é‡å»º â†’ é«˜åˆ†è¾¨ç‡ mesh
2. BEM/FEM å‰å‘å»ºæ¨¡ â†’ å¯¼è”åœºçŸ©é˜µ $G$
3. ç”µæå®šä½ (LeadDBS/iElectrodes) â†’ MNI åæ ‡
4. HCP tractography â†’ ç»“æ„è¿æ¥çŸ©é˜µ SC
5. LFM æ¦‚ç‡æŠ•å½± â†’ æºç©ºé—´æŒ‡æ ‡
6. SC Ã— FC â†’ è€¦åˆå›¾

**ç°å®è¯„ä¼°**ï¼šè¿™æ˜¯ä¸€æ¡ 6 ä¸ªæœˆçš„å·¥ç¨‹è·¯å¾„ï¼Œæ¯ä¸ªç¯èŠ‚éƒ½éœ€è¦ç‹¬ç«‹éªŒè¯ã€‚ä½†ä¸€æ—¦å»ºæˆï¼Œå¯ä»¥å®ç°ä»ç”µç”Ÿç†åˆ°è§£å‰–çš„æ— ç¼å¯¹æ¥ï¼Œè¿™æ˜¯æœ€ç»ˆçš„ä¸´åºŠè½¬åŒ–ç›®æ ‡ã€‚

---

### æ¨¡å—5: src/visualization.py âœ… é‡æ„å®Œæˆï¼ˆ2026-01-16ï¼‰

> **é“å¾‹**ï¼švisualization åªè´Ÿè´£è¯»å–å·²è®¡ç®—çš„ä¸­é—´ç»“æœå¹¶ç”»å›¾ï¼Œ**ä¸åšä»»ä½•å¤æ‚è®¡ç®—**ã€‚

#### èŒè´£è¾¹ç•Œ

**âœ… å…è®¸**:
1. è¯»å– `*_groupAnalysis.npz` æˆ– `*_envCache.npz`
2. æ ¹æ®å‚æ•°é€‰æ‹©å­é›†ï¼ˆé€šé“ã€äº‹ä»¶ï¼‰
3. è°ƒç”¨ matplotlib ç”»å›¾
4. ç®€å•çš„æ•°æ®åˆ‡ç‰‡ã€reshapeã€é¢œè‰²æ˜ å°„

**âŒ ç¦æ­¢**:
- è®¡ç®— STFT
- è®¡ç®—è´¨å¿ƒ
- è®¡ç®— Hilbert envelope
- ä»»ä½•è¶…è¿‡ 50 è¡Œçš„æ•°æ®å¤„ç†é€»è¾‘

---

#### åŠŸèƒ½æ€»è§ˆï¼šå¯è§†åŒ–äº§å‡ºä¸èµ„æºä¾èµ–

**A. åŸºç¡€å¯è§†åŒ–ï¼ˆæ•°æ®æ¢ç´¢ï¼‰**

| å‡½æ•° | äº§å‡ºå›¾è¡¨ | å¿…éœ€èµ„æº | ç”¨é€” |
|------|---------|---------|------|
| `plot_seeg_segment` | å¤šé€šé“æ—¶åºæ³¢å½¢ | `PreprocessingResult` (å†…å­˜å¯¹è±¡) | æŸ¥çœ‹é¢„å¤„ç†åæ•°æ® |
| `plot_from_result` | å¿«é€Ÿæ³¢å½¢å›¾ | `PreprocessingResult` | ä¾¿æ·å°è£… |
| `plot_shaft_channels` | å•ç”µæä¸²æ³¢å½¢ | `PreprocessingResult` | å®šä½å¼‚å¸¸ç”µæ |
| `plot_preprocessing_comparison` | å‰åå¯¹æ¯”å›¾ | 2ä¸ª `PreprocessingResult` | éªŒè¯é¢„å¤„ç†æ•ˆæœ |
| `plot_raw_filtered_envelope` | Raw/æ»¤æ³¢/åŒ…ç»œä¸‰è”å›¾ | `PreprocessingResult` + é€šé“é€‰æ‹© | æ£€æµ‹å™¨è°ƒè¯• |
| `plot_event_counts` | HFOäº‹ä»¶è®¡æ•°æŸ±çŠ¶å›¾ | `HFODetectionResult` | å¿«é€Ÿä¼ªè¿¹ç­›æŸ¥ |

**B. è®ºæ–‡çº§å¯è§†åŒ–ï¼ˆåªè¯»å–ä¸­é—´ç»“æœï¼‰**

| å‡½æ•° | äº§å‡ºå›¾è¡¨ | å¿…éœ€èµ„æº | å¯é€‰èµ„æº | ç”¨é€” |
|------|---------|---------|---------|------|
| `plot_paper_fig1_bandpassed_traces` | **Fig1**: æ‹¼æ¥äº‹ä»¶çª—å£çš„å¸¦é€šæ³¢å½¢ raster | `*_envCache.npz`<br>`*_packedTimes.npy` | - | å±•ç¤ºç¾¤ä½“äº‹ä»¶æ—¶åºç‰¹å¾ |
| `plot_group_event_tf_propagation_from_cache` | **Fig2**: å¤šé€šé“TFä¼ æ’­å›¾ï¼ˆé‡‘æ ‡å‡†ï¼‰ | `*_groupTF_tiles.npz`<br>`*_groupAnalysis.npz` | - | å±•ç¤ºç¾¤ä½“äº‹ä»¶TFåŸŸä¼ æ’­æ¨¡å¼ |
| `plot_lag_heatmaps_from_group_analysis` | **3å¼ çƒ­å›¾**: Energy/Rank/Lag (channelsÃ—events) | `*_groupAnalysis.npz`<br>`*_envCache.npz`<br>`*_packedTimes.npy` | - | é‡åŒ–ä¼ æ’­æ»åå’Œèƒ½é‡åˆ†å¸ƒ |
| `plot_lag_statistics` | **ç»Ÿè®¡ä¸‰è”å›¾**: Lagåˆ†å¸ƒ/Rankåˆ†å¸ƒ/é€šé“å‚ä¸ç‡ | `*_groupAnalysis.npz` | - | ç¾¤ä½“ç»Ÿè®¡ç‰¹å¾ |
| `plot_tf_centroid_statistics` | **TFè´¨å¿ƒç»Ÿè®¡**: é¢‘ç‡è´¨å¿ƒ/æ—¶é—´è´¨å¿ƒåˆ†å¸ƒ | `*_groupAnalysis.npz` | - | TFè´¨å¿ƒç‰¹å¾åˆ†æ |

**C. åº•å±‚å·¥å…·å‡½æ•°**

| å‡½æ•° | äº§å‡º | è¾“å…¥ | è¯´æ˜ |
|------|------|------|------|
| `detections_to_events` | äº‹ä»¶å­—å…¸åˆ—è¡¨ | `HFODetectionResult` | æ ¼å¼è½¬æ¢ï¼Œä¾› `plot_seeg_segment` å åŠ  |
| `plot_lag_heatmaps` | 3å¼ çƒ­å›¾ | numpy æ•°ç»„ | åº•å±‚ç»˜å›¾å‡½æ•°ï¼Œé€šå¸¸ç”¨é«˜å±‚å°è£… |

---

#### æ ¸å¿ƒèµ„æºæ–‡ä»¶é€ŸæŸ¥

**ä¸­é—´ç»“æœæ–‡ä»¶ï¼ˆå¿…éœ€ï¼‰**ï¼š

```python
# 1. Envelope + Bandpass ç¼“å­˜
"<record>_envCache_<band>_<ref>.npz"
â”œâ”€ env: (n_ch, n_samples) Hilbert envelope
â”œâ”€ x_band: (n_ch, n_samples) bandpassed signalï¼ˆå¯é€‰ï¼‰
â”œâ”€ sfreq: é‡‡æ ·ç‡
â””â”€ ch_names: é€šé“ååˆ—è¡¨

# 2. å®Œæ•´åˆ†æç»“æœ
"<record>_groupAnalysis.npz"
â”œâ”€ centroid_time: (n_ch, n_events) æ—¶é—´è´¨å¿ƒ
â”œâ”€ tf_centroid_time: (n_ch, n_events) TF 2Dè´¨å¿ƒ-æ—¶é—´åˆ†é‡ï¼ˆå¯é€‰ï¼‰
â”œâ”€ tf_centroid_freq: (n_ch, n_events) TF 2Dè´¨å¿ƒ-é¢‘ç‡åˆ†é‡ï¼ˆå¯é€‰ï¼‰
â”œâ”€ lag_raw: (n_ch, n_events) ç›¸å¯¹æ»å(ç§’)
â”œâ”€ lag_rank: (n_ch, n_events) æ’å(0=æœ€æ—©)
â”œâ”€ coact_event_count: (n_ch, n_ch) å…±åŒæ¿€æ´»äº‹ä»¶æ•°
â”œâ”€ coact_event_ratio: (n_ch, n_ch) å…±åŒæ¿€æ´»æ¯”ä¾‹
â”œâ”€ coact_time_ratio: (n_ch, n_ch) è´¨å¿ƒç»å¯¹æ—¶é—´å¯¹é½å¼ºåº¦
â”œâ”€ coact_rank_ratio: (n_ch, n_ch) è´¨å¿ƒç›¸å¯¹rankå¯¹é½å¼ºåº¦
â”œâ”€ events_bool: (n_ch, n_events) å‚ä¸mask
â””â”€ sfreq, band, ch_names, event_windows...

# 3. äº‹ä»¶çª—å£
"<record>_packedTimes.npy"
â””â”€ (n_events, 2) [start, end] ç§’

# 4. ç¾¤ä½“TFè°±å›¾ç¼“å­˜ï¼ˆFig2ï¼‰
"<record>_groupTF_tiles.npz"
â”œâ”€ power_db: (n_ch, n_events, n_freqs, n_time) 4D TF tiles (dB)
â”œâ”€ freqs_hz: (n_freqs,) å¯¹æ•°é¢‘ç‡è½´
â”œâ”€ event_indices: (n_events,) å¯¹åº”äº‹ä»¶ç´¢å¼•
â”œâ”€ channel_names: (n_ch,) é€šé“åˆ—è¡¨
â”œâ”€ window_sec: float äº‹ä»¶çª—å£é•¿åº¦
â””â”€ sfreq: float é‡‡æ ·ç‡

# 5. GPUæ£€æµ‹ç»“æœï¼ˆå¯é€‰ï¼Œç”¨äºmaskï¼‰
"<record>_gpu.npz"
â”œâ”€ whole_dets: List[(n_det, 2)] per channel
â””â”€ chns_names: é€šé“å
```

**å…¸å‹å¯è§†åŒ–æµç¨‹**ï¼š

```python
# Step 1: ç”Ÿæˆä¸­é—´ç»“æœï¼ˆä¸€æ¬¡æ€§ï¼‰
from src.group_event_analysis import compute_and_save_group_analysis
out_paths = compute_and_save_group_analysis(
    edf_path='FC10477Q.edf',
    output_dir='./output',
    output_prefix='FC10477Q',
    packed_times_path='FC10477Q_packedTimes.npy',
    gpu_npz_path='FC10477Q_gpu.npz',  # å¯é€‰
    band='ripple',
    reference='bipolar',
    save_env_cache=True,
)

# Step 2: å¯è§†åŒ–ï¼ˆä»»æ„å¤šæ¬¡ï¼Œåªè¯»å–ï¼‰
from src.visualization import (
    plot_paper_fig1_bandpassed_traces,
    plot_group_event_tf_spectrogram_from_cache,
    plot_lag_heatmaps_from_group_analysis,
    plot_lag_statistics,
    plot_tf_centroid_statistics,
)

# Fig1: æ³¢å½¢ raster
fig1 = plot_paper_fig1_bandpassed_traces(
    cache_npz_path=out_paths['env_cache_path'],
    packed_times_path='FC10477Q_packedTimes.npy',
    channel_order=CORE_CHANNELS,
    event_indices=list(range(30)),
)

# Fig2: å¤šé€šé“TFä¼ æ’­ï¼ˆé‡‘æ ‡å‡†ï¼‰
fig2 = plot_group_event_tf_propagation_from_cache(
    tfr_tile_cache_npz_path=out_paths['group_tf_tile_cache_path'],
    group_analysis_npz_path=out_paths['group_analysis_path'],
    channel_order=CORE_CHANNELS,
    event_indices=list(range(30)),
    plot_window_sec=0.1,  # 100ms æ—¶é—´çª—å£
    low_color="#1f4b99",  # è“è‰²èƒŒæ™¯
    low_color_percentile=70.0,  # ä½äº70%è®¾ä¸ºèƒŒæ™¯
    cmap="Reds",  # çº¢è‰²èƒ½é‡æ˜ å°„
)

# çƒ­å›¾: Energy/Rank/Lag
figE, figR, figL = plot_lag_heatmaps_from_group_analysis(
    group_analysis_npz=out_paths['group_analysis_path'],
    env_cache_npz=out_paths['env_cache_path'],
    packed_times_npy='FC10477Q_packedTimes.npy',
    channel_names=CORE_CHANNELS,
    max_events=100,
)

# ç»Ÿè®¡å›¾
fig_stats = plot_lag_statistics(
    group_analysis_npz=out_paths['group_analysis_path'],
    patient_id='chengshuai',
    record_id='FC10477Q',
)

# TFè´¨å¿ƒç»Ÿè®¡
fig_tf = plot_tf_centroid_statistics(
    group_analysis_npz=out_paths['group_analysis_path'],
)
```

---

#### é‡æ„æ€»ç»“ï¼ˆ2026-01-16ï¼‰

âœ… **å®Œæˆçš„é‡æ„**ï¼š
1. âœ… å°† TF è´¨å¿ƒè®¡ç®—ä» `visualization.py` è¿ç§»åˆ° `group_event_analysis.py`
2. âœ… æ·»åŠ  `compute_tf_centroids()` è®¡ç®— 2D TF è´¨å¿ƒï¼ˆæ—¶é—´+é¢‘ç‡ï¼‰
3. âœ… `*_groupAnalysis.npz` ç°åœ¨åŒ…å« `tf_centroid_time` å’Œ `tf_centroid_freq`
4. âœ… `plot_paper_fig2_*` é‡æ„ä¸ºè¯»å–é¢„è®¡ç®—è´¨å¿ƒï¼Œä¸å†å†…éƒ¨è®¡ç®— STFT
5. âœ… æ–°å¢ä¾¿åˆ©å‡½æ•°ï¼š
   - `plot_lag_heatmaps_from_group_analysis()` - ä¸€é”®è¯»å–+ç»˜åˆ¶çƒ­å›¾
   - `plot_lag_statistics()` - ç»Ÿè®¡åˆ†æä¸‰è”å›¾
   - `plot_tf_centroid_statistics()` - TFè´¨å¿ƒåˆ†å¸ƒç»Ÿè®¡
6. âœ… `chengshuai_hfo_analysis.ipynb` é‡æ„ä¸ºçº¯å¯è§†åŒ–ç»ˆç«¯ï¼ˆä¸åšè®¡ç®—ï¼‰

**æ¶æ„éªŒè¯**ï¼š
- âœ… visualization.py ä¸å†æœ‰ä»»ä½• STFT/è´¨å¿ƒè®¡ç®—é€»è¾‘
- âœ… æ‰€æœ‰å¤æ‚è®¡ç®—åœ¨ `group_event_analysis.py`
- âœ… notebook åªè°ƒç”¨ visualization å‡½æ•°ï¼Œä¸å†™å†…è”ç»˜å›¾ä»£ç 
- âœ… ä¸­é—´ç»“æœå¯å¤ç”¨ï¼Œé¿å…é‡å¤è®¡ç®—

**å…³é”®æŠ€æœ¯å†³ç­–**:
- **æ³¢å½¢é¢œè‰²**: `tableau_20_no_red` é¿å…ä¸HFOçº¢è‰²æ ‡è®°å†²çª
- **äº‹ä»¶æ ‡æ³¨**: é»˜è®¤ `style='tick'` ç»†çº¿ï¼Œä¸é®æŒ¡æ³¢å½¢
- **TFè´¨å¿ƒ**: ä½¿ç”¨ wavelet TFR + åŠ¨æ€åŸºçº¿logæ ¡æ­£ï¼Œå†åœ¨è¯¥TFå›¾ä¸Šè®¡ç®—2Dè´¨å¿ƒ

---

## 5. å¿«é€Ÿå¼€å‘å‚è€ƒ

### 5.1 preprocessing.py å¿«é€Ÿä¸Šæ‰‹

```python
from src.preprocessing import SEEGPreprocessor

# æ ‡å‡†ç”¨æ³•ï¼ˆè‡ªåŠ¨é€‰æ‹©é‡‡æ ·ç‡ï¼‰
preprocessor = SEEGPreprocessor(
    target_band='ripple',        # 'ripple' (1000Hz) or 'fast_ripple' (2000Hz)
    reference='bipolar',         # 'bipolar' / 'car' / 'none'
    use_gpu=True,                # è‡ªåŠ¨é™çº§åˆ° CPU å¦‚æœæ—  GPU
)
result = preprocessor.run('path/to/file.edf')

# å¤ç° GPU é€šé“åˆ—è¡¨ï¼ˆæ˜¾å¼ï¼‰
gpu_data = np.load('FC10477Q_gpu.npz', allow_pickle=True)
gpu_channels = [str(ch) for ch in gpu_data['chns_names']]

preprocessor = SEEGPreprocessor(
    reference='bipolar',
    include_channels=gpu_channels,  # æ˜¾å¼é€šé“ç™½åå•
)

# æ’é™¤åé€šé“ï¼ˆæ˜¾å¼ï¼‰
preprocessor = SEEGPreprocessor(
    reference='bipolar',
    exclude_channels=['A1-A2', 'EMG1-EMG2'],  # æ˜¾å¼é»‘åå•
)

# æ·»åŠ è‡ªå®šä¹‰ FilterBackendï¼ˆé«˜çº§ï¼‰
from src.preprocessing import FilterBackend

class MyCustomBackend(FilterBackend):
    def apply_notch(self, data, sfreq, freqs):
        # ä½ çš„å®ç°
        return data
    
    def apply_bandpass(self, data, sfreq, low, high):
        # ä½ çš„å®ç°
        return data

preprocessor = SEEGPreprocessor()
preprocessor.filter_backend = MyCustomBackend()
```

### 5.2 å¸¸è§ä»»åŠ¡é€ŸæŸ¥

| ä»»åŠ¡ | ä»£ç  |
|------|------|
| **é¢„å¤„ç† + HFOæ£€æµ‹** | `preprocessor.run(edf) -> detector.detect(result.data, result.sfreq)` |
| **å®Œæ•´åˆ†ææµç¨‹** | `compute_and_save_group_analysis(edf_path, ...)` |
| **å¯è§†åŒ–è®ºæ–‡å›¾** | `plot_paper_fig1_bandpassed_traces(env_cache_npz, ...)` |
| **è¯»å–ä¸­é—´ç»“æœ** | `load_group_analysis_results('*_groupAnalysis.npz')` |
| **Envelope ç¼“å­˜** | `precompute_envelope_cache(data, sfreq, ch_names, ...)` |

### 5.3 æœªæ¥é‡æ„è®¡åˆ’ï¼ˆå¯é€‰ï¼Œä½ä¼˜å…ˆçº§ï¼‰

**Phase 2: èŒè´£åˆ†ç¦»ï¼ˆLoader/Processorï¼‰**
- ç›®æ ‡ï¼šæ‹†åˆ† EDF åŠ è½½å’Œæ•°æ®å˜æ¢é€»è¾‘
- æ”¶ç›Šï¼šæ”¯æŒå¤šç§æ•°æ®æ ¼å¼ï¼ˆBrainVision, Neuralynx, ...ï¼‰
- è§¦å‘æ¡ä»¶ï¼šéœ€è¦æ”¯æŒ â‰¥3 ç§æ•°æ®æ ¼å¼æ—¶

**Phase 3: ç§»åŠ¨ seizure detection**
- ç›®æ ‡ï¼š`detect_seizure_onsets_from_data()` â†’ `src/seizure_detection.py`
- æ”¶ç›Šï¼šæ¨¡å—èŒè´£æ›´æ¸…æ™°ï¼ˆpreprocessing ä¸åº”åŒ…å«åˆ†æé€»è¾‘ï¼‰
- è§¦å‘æ¡ä»¶ï¼šéœ€è¦æ‰©å±•å¤šç§å‘ä½œæ£€æµ‹ç®—æ³•æ—¶

## 6. å…³é”®æŠ€æœ¯é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ

| é™·é˜± | é—®é¢˜æè¿° | è§£å†³æ–¹æ¡ˆ |
|------|----------|----------|
| "Pre-bipolaræ¨æ–­" | é€šè¿‡"æœ«ç«¯contactç¼ºå¤±"æ¨æ–­EDFå·²bipolar â†’ **è¯¯è§£** | **ç¦æ­¢æ¨æ–­**ï¼›éœ€è¦ä»€ä¹ˆå°±æ˜¾å¼ `reference='bipolar'/'car'/'none'` |
| Bipolaræ–­æ¡¥ | è·¨ç”µæä¸²å·®åˆ†äº§ç”Ÿä¼ªä¿¡å· | ä¸¥æ ¼è§£æç”µæå‰ç¼€, ä»…åŒä¸²ç›¸é‚» |
| FRé‡‡æ ·ç‡ | 1000Hzä¸‹500Hzä¸¥é‡è¡°å‡ | FRåˆ†æä¿ç•™2000Hz |
| Ictalé˜ˆå€¼ | å‘ä½œæœŸæ‹‰é«˜å…¨å±€é˜ˆå€¼ | å‰”é™¤Ictalåè®¡ç®—åŸºçº¿ |
| é¸¡ç”Ÿè›‹é—®é¢˜ | HFOç°‡è¢«è¯¯åˆ¤ä¸ºIctal | æŒç»­æ—¶é—´çº¦æŸ >3ç§’ |
| ç›¸ä½æ»‘ç§» | XCorr cycle skipping | å¯¹**HilbertåŒ…ç»œ**åšäº’ç›¸å…³ |
| æ ¸å¿ƒé€šé“å¾ªç¯è®ºè¯ | é«˜å¯†åº¦â‰ Source | å¤šç­–ç•¥å¯¹æ¯”ç­›é€‰ |
| å›¾éè¿é€š | Eccentricityè®¡ç®—å¤±æ•ˆ | Harmonic Centralityæ›¿ä»£ |
| é›¶æ»åç¦»æ•£åŒ– | è¿‘è·å¿«é€Ÿä¼ æ’­è¢«è¯¯æ€ | è·ç¦»æ¡ä»¶å‰”é™¤ (ä»…è¿œè·lag=0) |
| **GPUä¸å¯ç”¨** | æœåŠ¡å™¨æœ‰GPUæœ¬åœ°æ—  | æ‰€æœ‰ç®—æ³•CPU/GPUåŒç‰ˆæœ¬, è‡ªåŠ¨é™çº§ |

---

## 7. å¼€å‘è¿›åº¦

- [x] é¡¹ç›®ç»“æ„è®¾è®¡
- [x] å¼€å‘è®¡åˆ’æ–‡æ¡£
- [x] **æ¨¡å—1: preprocessing.py** âœ… Phase 1 é‡æ„å®Œæˆ (2026-01-30)
  - [x] ç”µæåç§°è§£æ (ElectrodeParser)
  - [x] é‡å‚è€ƒï¼ˆæ˜¾å¼ï¼‰:
    - [x] Bipolar (BipolarReferencer) â€” å‘½å `A1-A2`
    - [x] CAR per shaft (CommonAverageReferencer)
    - [x] Noneï¼ˆä¿æŒåŸå§‹EDFï¼‰
  - [x] é€šé“é€‰æ‹©ï¼ˆæ˜¾å¼ï¼‰: include/exclude channelsï¼ˆç”¨äºåŒ¹é…GPUé€šé“åˆ—è¡¨ï¼‰
  - [x] é‡é‡‡æ · + Notchæ»¤æ³¢
  - [x] **âœ… FilterBackend æ¶æ„é‡æ„** - æ¶ˆé™¤æ‰€æœ‰ GPU if/else åˆ†æ”¯
  - [x] **âœ… åˆ é™¤åºŸä»£ç ** - PreBipolarDetector, validate_against_gpu_results, exclude_last_n
  - [x] GPUåŠ é€Ÿæ”¯æŒ (CuPyå¯é€‰)
  - [x] é€šé“è´¨é‡æ£€æŸ¥
  - [x] chengshuai/FC10477Q: EDF vs GPU é€šé“å·®å¼‚æ¥æºç¡®è®¤ï¼ˆGPU=æ˜¾å¼é€šé“å­é›†ï¼›ä¸ç”¨äºæ¨æ–­é‡å‚è€ƒï¼‰
- [x] **æ¨¡å—2: hfo_detector.py** âœ… Phase 2 é‡æ„å®Œæˆï¼ˆ2026-01-31ï¼‰
  - [x] åˆ é™¤ `mad_hysteresis` ç®—æ³•ï¼ˆ-200è¡Œï¼‰
  - [x] å°è£… `BQKDetector` ç±»ï¼ˆé¢„è®¡ç®—æ»¤æ³¢å™¨ç³»æ•°ï¼‰
  - [x] å®ç° joblib å¹¶è¡ŒåŒ–ï¼ˆå¤šå¸¦åŒ…ç»œè®¡ç®—ï¼‰
  - [x] æ€§èƒ½æµ‹è¯•ï¼šä¸²è¡Œ vs å¹¶è¡Œï¼ˆå‘ç°å°æ•°æ®å¹¶è¡Œåè€Œæ…¢ï¼‰
  - [x] åŒé˜ˆå€¼æ£€æµ‹ï¼ˆrel_thresh Ã— local_median âˆ§ abs_thresh Ã— global_medianï¼‰
  - [x] äº‹ä»¶åˆå¹¶ç­›é€‰ï¼ˆmin_gap + min_lastï¼‰
  - [x] Ripple/FRåˆ†ç¦»
  - [x] Chunkedå¤„ç†ï¼ˆ30s chunk + 1s overlapï¼‰
  - [x] æ•°å€¼éªŒè¯ï¼šä¸åŸ `bqk_utils.py` è¯¯å·® <1e-9
- [x] **æ¨¡å—3: group_event_analysis.py** âœ… 2026-01-16ï¼ˆæ ¸å¿ƒé€»è¾‘å®Œæˆï¼‰
  - [x] çª—å£æ„å»º (build_windows_from_detections)
  - [x] Envelopeç¼“å­˜ (precompute_envelope_cache)
  - [x] è´¨å¿ƒè®¡ç®— (compute_centroid_matrix_from_envelope_cache)
  - [x] Lag/Rankè®¡ç®— (lag_rank_from_centroids)
  - [x] é€šé“ç­›é€‰ (select_core_channels_by_event_count)
  - [x] éªŒè¯å‡½æ•° (validate_* ç³»åˆ—)
  - [x] TFè´¨å¿ƒè®¡ç®— (compute_tf_centroids) âœ…
  - [x] ç»Ÿä¸€ç»“æœå­˜å‚¨ (save_group_analysis_results) âœ…
  - [x] ä¸€é”®API (compute_and_save_group_analysis) âœ…
- [x] **æ¨¡å—5: visualization.py** âœ… 2026-01-16ï¼ˆé‡æ„å®Œæˆï¼‰
  - [x] åŸºç¡€å¯è§†åŒ–ï¼ˆæ³¢å½¢ã€äº‹ä»¶æ ‡æ³¨ã€è°ƒè¯•è§†å›¾ï¼‰
  - [x] Fig1: å¸¦é€šæ³¢å½¢ rasterï¼ˆè¯»å– envCacheï¼‰
  - [x] Fig2: TFåŠŸç‡+è´¨å¿ƒè·¯å¾„ï¼ˆè¯»å– groupAnalysis é¢„è®¡ç®—è´¨å¿ƒï¼‰
  - [x] çƒ­å›¾ï¼šEnergy/Rank/Lagï¼ˆè¯»å– groupAnalysisï¼‰
  - [x] ç»Ÿè®¡åˆ†æï¼šLag/Rank/Participationï¼ˆè¯»å– groupAnalysisï¼‰
  - [x] TFè´¨å¿ƒç»Ÿè®¡ï¼ˆè¯»å– groupAnalysisï¼‰
  - [x] âœ… æ¶æ„é‡æ„ï¼šå‰¥ç¦»æ‰€æœ‰ STFT/è´¨å¿ƒè®¡ç®—åˆ° group_event_analysis
  - [ ] ä¼ æ’­åŠ¨å›¾ï¼ˆ500msçª—å£å†…èƒ½é‡ä¼ æ’­åŠ¨ç”»ï¼‰
  - [ ] ç½‘ç»œæ‹“æ‰‘å›¾ï¼ˆå¾…æ¨¡å—4ï¼‰
- [ ] **æ¨¡å—4: network_analysis.py** (ä¸‰é˜¶æ®µé€’è¿›, v2: å®½å»ºå›¾â†’ç²¾å‰ªæâ†’å®šæ–¹å‘)
  - [ ] **Phase A: Channel-Scale MVP**
    - [ ] A.1 å®½å»ºå›¾ (Simpson Index å½’ä¸€åŒ–å…±æ¿€æ´»)
    - [ ] A.2 æ›¿ä»£æ•°æ®æ˜¾è‘—æ€§æ£€éªŒ (Surrogate)
    - [ ] A.3-A.4 XYZ ç‰¹å¾è®¡ç®— + å¤šç»´å‰ªæ (Rate Ã— Entropy Ã— è°±èšç±»)
    - [ ] A.5 æ–¹å‘æ³¨å…¥ (Wilcoxon + ä¸€è‡´æ€§)
    - [ ] A.6-A.7 Stability æƒé‡ + å¤åˆæƒé‡
    - [ ] A.8 å›¾è®ºæŒ‡æ ‡ (Net Outflow, Local Efficiency, Betweenness)
    - [ ] A.9-A.10 2D ç½‘ç»œæ‹“æ‰‘å›¾ + XY æ•£ç‚¹è¯Šæ–­å›¾ + ä¼ æ’­è·¯å¾„
  - [ ] **Phase B: Channel + Geometry** (é˜»å¡äº MNI åæ ‡)
    - [ ] B.0 ç”µæåæ ‡è·å–
    - [ ] B.1-B.3 ç©ºé—´çº¦æŸ + å®¹ç§¯ä¼ å¯¼å‰”é™¤ + ä¼ æ’­é€Ÿåº¦éªŒè¯
    - [ ] B.4 ç—…ç†åŠ æƒ (FR åˆ†ç±» â†’ Z ç»´åº¦å‡çº§)
    - [ ] B.5-B.6 3D è„‘å›¾ + Ictal vs Interictal å¯¹æ¯”
  - [ ] **Phase C: Source Space** (ç ”ç©¶å‰æ²¿)
- [x] Notebook: chengshuai_hfo_analysis.ipynb âœ…
- [x] 2026-02-01: toy timelag + env cache æ¥å£æµ‹è¯•ï¼ˆcuda_envï¼‰
- [ ] éªŒè¯ä¸åŸç»“æœä¸€è‡´æ€§
- [ ] å®Œæ•´Pipelineæµ‹è¯•

---

## 8. æµ‹è¯•æ•°æ®

**ç¤ºä¾‹æ‚£è€…**: chengshuai  
**ç¤ºä¾‹è®°å½•**: FC10477Q  
**æ•°æ®è·¯å¾„**: `/mnt/yuquan_data/yuquan_24h_edf/chengshuai/FC10477Q.edf`

**é¢„æœŸè¾“å‡º**:
- Bipolaré€šé“æ•°: ~130ï¼ˆå–å†³äºæ¯æ ¹ç”µæä¸²contactæ•°é‡ä¸ç¼ºå¤±æƒ…å†µï¼‰
- GPUæ£€æµ‹äº‹ä»¶æ•°: 46,738
- æ ¸å¿ƒé€šé“: ['E11', 'K3', 'K5', 'K6', 'K7', 'K8', 'K9', 'K10']
- å¯¹é½äº‹ä»¶æ•°: 2,601

**NotebookéªŒè¯ç»“æœï¼ˆ100s cropï¼‰**:
- Detections: 10232 total
- Top channels: ['K15-K16', 'G13-G14', 'J9-J10', 'K6-K7', 'D13-D14', ...]
