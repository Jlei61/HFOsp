# HFOsp å¼€å‘è®¡åˆ’

**é¡¹ç›®ç›®æ ‡**: å¤ç°å¹¶æ‰©å±• HFO (é«˜é¢‘æŒ¯è¡) åˆ†ææµç¨‹ï¼ŒéªŒè¯ Source-Sink ç†è®º  
**æ•°æ®é›†**: ç‰æ³‰24å°æ—¶SEEGæ•°æ®é›†  
**æ•°æ®è·¯å¾„**: `/mnt/yuquan_data/yuquan_24h_edf`  
**æ›´æ–°æ—¥æœŸ**: 2026-01-16

---

## 0. æ ¸å¿ƒæ¶æ„åŸåˆ™

### æ•°æ®æµè®¾è®¡å“²å­¦

> "Bad programmers worry about the code. Good programmers worry about data structures." â€” Linus Torvalds

**å•ä¸€èŒè´£åŸåˆ™**ï¼šæ¯ä¸ªæ¨¡å—åªåšä¸€ä»¶äº‹å¹¶åšå¥½ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              HFOsp æ•°æ®æµæ¶æ„                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  [åŸå§‹EDF]                                                                      â”‚
â”‚      â”‚                                                                          â”‚
â”‚      â–¼                                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                            â”‚
â”‚  â”‚ preprocessing   â”‚ â”€â”€â†’ é¢„å¤„ç†ï¼šé‡å‚è€ƒã€æ»¤æ³¢ã€é€šé“é€‰æ‹©                          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                            â”‚
â”‚           â”‚ (data, sfreq, ch_names)                                             â”‚
â”‚           â–¼                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                            â”‚
â”‚  â”‚  hfo_detector   â”‚ â”€â”€â†’ HFOæ£€æµ‹ï¼šå•é€šé“äº‹ä»¶åˆ—è¡¨                                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                            â”‚
â”‚           â”‚ Dict[ch_name â†’ [(start, end), ...]]                                 â”‚
â”‚           â–¼                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚  â”‚           group_event_analysis                       â”‚                       â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚                        â”‚
â”‚  â”‚  â”‚ Step 1: ç¾¤ä½“äº‹ä»¶çª—å£æ„å»º                      â”‚    â”‚                       â”‚
â”‚  â”‚  â”‚   - build_windows_from_detections           â”‚    â”‚                        â”‚
â”‚  â”‚  â”‚   - è¾“å‡º: EventWindow list                   â”‚    â”‚                       â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚                        â”‚
â”‚  â”‚                     â–¼                               â”‚                        â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚                        â”‚
â”‚  â”‚  â”‚ Step 2: é¢„è®¡ç®— Envelope ç¼“å­˜ï¼ˆbandpasså¯é€‰ï¼‰   â”‚    â”‚                       â”‚
â”‚  â”‚  â”‚   - precompute_envelope_cache               â”‚    â”‚                        â”‚
â”‚  â”‚  â”‚   - å­˜å‚¨: *_envCache.npz                    â”‚    â”‚                        â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚                        â”‚
â”‚  â”‚                     â–¼                               â”‚                        â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚                        â”‚
â”‚  â”‚  â”‚ Step 3: è´¨å¿ƒåˆ†æï¼ˆTFå¯é€‰ï¼‰â†’ å­˜å‚¨ä¸­é—´ç»“æœ       â”‚    â”‚                       â”‚
â”‚  â”‚  â”‚   - compute_group_analysis_results          â”‚    â”‚                        â”‚
â”‚  â”‚  â”‚   - å­˜å‚¨: *_groupAnalysis.npz               â”‚    â”‚ â† å…³é”®æ–°å¢ï¼           â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚                        â”‚
â”‚  â”‚                     â”‚                               â”‚                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                        â”‚                                                        â”‚
â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                           â”‚
â”‚           â–¼                         â–¼                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                   â”‚
â”‚  â”‚ network_analysisâ”‚      â”‚  visualization  â”‚ â† åªè¯»å–ä¸­é—´ç»“æœï¼Œä¸åšè®¡ç®—ï¼       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   â”‚
â”‚                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ä¸­é—´ç»“æœå­˜å‚¨è§„èŒƒ

**å­˜å‚¨ä½ç½®**: `/mnt/yuquan_data/yuquan_24h_edf/<patient>/`ï¼ˆä¸EDFåŒç›®å½•ï¼‰

| æ–‡ä»¶åæ¨¡å¼ | å†…å®¹ | æ¥æºæ¨¡å— |
|-----------|------|----------|
| `*_gpu.npz` | å†å²GPUæ£€æµ‹ç»“æœ | (å·²æœ‰) |
| `*_packedTimes.npy` | äº‹ä»¶çª—å£ | (å·²æœ‰) |
| `*_lagPat*.npz` | å†å²lagçŸ©é˜µ | (å·²æœ‰) |
| `*_envCache_{band}_{ref}.npz` | **Envelopeç¼“å­˜ï¼ˆx_bandå¯é€‰ï¼‰** | `group_event_analysis` |
| `*_groupAnalysis.npz` | **è´¨å¿ƒ+lagï¼ˆTFå¯é€‰ï¼‰åˆ†æç»“æœ** | `group_event_analysis` |

### `*_groupAnalysis.npz` ç»“æ„ï¼ˆæ ¸å¿ƒæ–°å¢ï¼‰

```python
{
    # === å…ƒæ•°æ® ===
    'sfreq': np.array([2000.0]),           # é‡‡æ ·ç‡
    'band': np.array(['ripple']),          # é¢‘æ®µ
    'ch_names': np.array([...]),           # æ ¸å¿ƒé€šé“å (n_ch,)
    'window_sec': np.array([0.5]),         # çª—å£é•¿åº¦
    'n_events': np.array([2601]),          # äº‹ä»¶æ•°
    'n_channels': np.array([8]),           # é€šé“æ•°
    
    # === äº‹ä»¶çª—å£ ===
    'event_windows': np.array([...]),      # (n_events, 2) [start, end] ç§’
    
    # === è´¨å¿ƒåˆ†æ ===
    'centroid_time': np.array([...]),      # (n_ch, n_events) æ—¶é—´è´¨å¿ƒ(ç›¸å¯¹çª—å£èµ·å§‹, é»˜è®¤env)
    'tf_centroid_time': np.array([...]),   # (n_ch, n_events) TFè´¨å¿ƒæ—¶é—´åˆ†é‡ï¼ˆå¯é€‰ï¼‰
    'tf_centroid_freq': np.array([...]),   # (n_ch, n_events) TFè´¨å¿ƒé¢‘ç‡åˆ†é‡ï¼ˆå¯é€‰ï¼‰
    'events_bool': np.array([...]),        # (n_ch, n_events) é€šé“æ˜¯å¦å‚ä¸
    
    # === Lag/Rank åˆ†æ ===
    'lag_raw': np.array([...]),            # (n_ch, n_events) ç›¸å¯¹lag(å¯¹é½åˆ°æœ€æ—©é€šé“)
    'lag_rank': np.array([...]),           # (n_ch, n_events) æ’å (0=æœ€æ—©)

    # === Co-activation (ch Ã— ch) ===
    'coact_event_count': np.array([...]),  # (n_ch, n_ch) å…±åŒæ¿€æ´»äº‹ä»¶æ•°
    'coact_event_ratio': np.array([...]),  # (n_ch, n_ch) å…±åŒæ¿€æ´»æ¯”ä¾‹ (=count/n_events)
    'coact_time_ratio': np.array([...]),   # (n_ch, n_ch) è´¨å¿ƒç»å¯¹æ—¶é—´å¯¹é½å¼ºåº¦(0..1)
    'coact_rank_ratio': np.array([...]),   # (n_ch, n_ch) è´¨å¿ƒç›¸å¯¹rankå¯¹é½å¼ºåº¦(0..1)
    
    # === å¯é€‰ï¼šTF å˜æ¢ç»“æœ (ç”¨äºé«˜çº§å¯è§†åŒ–) ===
    'tf_power_per_event': np.array([...]), # (n_ch, n_events, n_freq, n_time) å¯é€‰
}
```

### Visualization èŒè´£è¾¹ç•Œï¼ˆé“å¾‹ï¼‰

**visualization.py åªè´Ÿè´£**ï¼š
1. è¯»å– `*_groupAnalysis.npz` æˆ– `*_envCache.npz`
2. æ ¹æ®å‚æ•°é€‰æ‹©å­é›†ï¼ˆé€šé“ã€äº‹ä»¶ï¼‰
3. è°ƒç”¨ matplotlib ç”»å›¾

**visualization.py ç¦æ­¢**ï¼š
- âŒ è®¡ç®— STFT
- âŒ è®¡ç®—è´¨å¿ƒ
- âŒ è®¡ç®— Hilbert envelope
- âŒ ä»»ä½•è¶…è¿‡ 100 è¡Œçš„æ•°æ®å¤„ç†

---

## 1. æ•°æ®é›†æ¦‚è§ˆ

| æŒ‡æ ‡ | æ•°å€¼ |
|------|------|
| æ‚£è€…æ•°é‡ | 21äºº (14äººå·²å¤„ç†) |
| EDFæ–‡ä»¶ | 260ä¸ª (çº¦520å°æ—¶) |
| é‡‡æ ·ç‡ | 2000 Hz |
| å•æ–‡ä»¶æ—¶é•¿ | çº¦2å°æ—¶ |
| é€šé“æ•° | 145 (åŸå§‹, å«éSEEG) â†’ ~140 (SEEG) â†’ ~130 (Bipolarå‚è€ƒåå¯¹) â†’ 8 (æ ¸å¿ƒ, lagPat) |
| HFOäº‹ä»¶ | ~170ä¸‡+ |

**å·²æœ‰ä¸­é—´ç»“æœ**:
- `*_gpu.npz`: 120é€šé“ Ã— å˜é•¿äº‹ä»¶åˆ—è¡¨
- `*_lagPat.npz`: 8é€šé“ Ã— 2601äº‹ä»¶ æ»åçŸ©é˜µ  
- `*_packedTimes.npy`: äº‹ä»¶æ—¶é—´çª— [start, end]
- `hist_meanX.npz`: æ ¸å¿ƒé€šé“ç­›é€‰ç»“æœ

---

## 2. ç°æœ‰æ–‡ä»¶ç»“æ„

```
HFOsp/
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ DEVELOP_PLAN.md          # æœ¬æ–‡ä»¶
â”‚   â”œâ”€â”€ README_YUQUAN.md         # æ•°æ®é›†ä½¿ç”¨è¯´æ˜
â”‚   â””â”€â”€ yuquan_24h_dataset_structure.md  # æ•°æ®ç»“æ„è¯¦è§£
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py              # âœ… æ¨¡å—å¯¼å‡º
â”‚   â”œâ”€â”€ preprocessing.py         # âœ… é¢„å¤„ç†Pipeline
â”‚   â”œâ”€â”€ hfo_detector.py          # âœ… HFOæ£€æµ‹å™¨
â”‚   â”œâ”€â”€ group_event_analysis.py  # âœ… ç¾¤ä½“äº‹ä»¶åˆ†æï¼ˆæ ¸å¿ƒè®¡ç®—ä¸­å¿ƒï¼‰
â”‚   â”œâ”€â”€ network_analysis.py      # [å¾…å¼€å‘] ç½‘ç»œåˆ†æ
â”‚   â”œâ”€â”€ visualization.py         # âš ï¸ å¯è§†åŒ–ï¼ˆéœ€é‡æ„ï¼šå‰¥ç¦»è®¡ç®—é€»è¾‘ï¼‰
â”‚   â””â”€â”€ utils/
â”‚       â””â”€â”€ bqk_utils.py         # åŸºç¡€å·¥å…·å‡½æ•°
â”œâ”€â”€ datasets/
â”‚   â”œâ”€â”€ quick_view_yuquan.py     # æ•°æ®å¿«é€ŸæŸ¥çœ‹
â”‚   â””â”€â”€ ...
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ visualize_event_waveforms.py
â”‚   â””â”€â”€ yuquan_analysis.py
â”œâ”€â”€ notebook/
â”‚   â””â”€â”€ chengshuai_hfo_analysis.ipynb  # âœ… ç¤ºä¾‹notebook
â”œâ”€â”€ yuquan_dataloader.py         # æ•°æ®åŠ è½½å™¨
â””â”€â”€ requirements.txt             # [å¾…åˆ›å»º]
```

---

## 3. æ ¸å¿ƒæ•°æ®æµ

```
åŸå§‹EDF (145é€šé“, 2000Hz, 2h) 
    â”‚
    â”œâ”€ ç”µæåç§°è§£æ (å»POL/EEGå‰ç¼€, æ’é™¤EMG/ECG)
    â”‚
    â”œâ”€ Bipolaré‡å‚è€ƒ (åŒç”µæä¸²ç›¸é‚»è§¦ç‚¹å·®åˆ†)
    â”‚   â””â”€ ä¸¥æ ¼è§„åˆ™: ä»…åŒå‰ç¼€ + æ•°å­—è¿ç»­/ç›¸é‚»
    â”‚   â””â”€ 145 â†’ çº¦120é€šé“
    â”‚
    â”œâ”€ é‡é‡‡æ · (Ripple: 1000Hz, FR: ä¿ç•™2000Hz)
    â”‚
    â”œâ”€ æ»¤æ³¢ (Notch 50Hzè°æ³¢ + Bandpass)
    â”‚
    â””â”€ é€šé“è´¨é‡æ£€æŸ¥ (z-scoreå¼‚å¸¸, æ–¹å·®æ£€æµ‹)
         â”‚
         â–¼
    æ»¤æ³¢åæ•°æ® (120é€šé“, 1000/2000Hz)
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚         â”‚
  Ripple    Fast-Ripple
 80-250Hz   250-500Hz
    â”‚         â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚
    HFOäº‹ä»¶æ£€æµ‹ (HilbertåŒ…ç»œ + åŒé˜ˆå€¼)
         â”‚
         â”œâ”€ Ictalæ®µè½æ£€æµ‹ (èƒ½é‡çˆ†å‘ + æŒç»­>3s)
         â”œâ”€ èƒŒæ™¯åŸºçº¿ä¼°è®¡ (å‰”é™¤Ictalåè®¡ç®—)
         â””â”€ åˆ†æ®µè‡ªé€‚åº”é˜ˆå€¼
         â”‚
         â–¼
    å•é€šé“HFOäº‹ä»¶åˆ—è¡¨
         â”‚
    ç¾¤ä½“äº‹ä»¶è¯†åˆ« (500msçª—å£å†…å¤šé€šé“å…±ç°)
         â”‚
         â”œâ”€ æ»åè®¡ç®— (HilbertåŒ…ç»œäº’ç›¸å…³)
         â”œâ”€ æ ¸å¿ƒé€šé“ç­›é€‰ (å¯†åº¦/Out-Strength/é¦–å‘)
         â””â”€ é¢‘ç‡ä¸­å¿ƒè®¡ç®—
         â”‚
         â–¼
    æ»åçŸ©é˜µ (8æ ¸å¿ƒé€šé“ Ã— Näº‹ä»¶)
         â”‚
    æœ‰å‘ç½‘ç»œæ„å»º
         â”‚
         â”œâ”€ å®¹ç§¯ä¼ å¯¼å‰”é™¤ (è·ç¦»+æ»åæ¡ä»¶)
         â”œâ”€ Interictal/Ictal åˆ†æ®µç½‘ç»œ
         â””â”€ å›¾è®ºæŒ‡æ ‡è®¡ç®—
         â”‚
         â–¼
    Source-Sink éªŒè¯
```

---

## 4. æ¨¡å—å¼€å‘è®¡åˆ’

### æ¨¡å—1: src/preprocessing.py âœ… å®Œæˆï¼ˆPhase 1 é‡æ„ 2026-01-30ï¼‰

| åŠŸèƒ½ | è¯´æ˜ | çŠ¶æ€ |
|------|------|------|
| 1.1 EDFè¯»å– | åŠ è½½EDF, æ¸…æ´—ç”µæåç§°, encoding='latin1' | âœ… |
| 1.2 ç”µæåç§°è§£æ | æ­£åˆ™æå– (prefix, number), æ”¯æŒA'5æ ¼å¼ | âœ… |
| 1.3 é‡å‚è€ƒç­–ç•¥ | **æ˜¾å¼** bipolar / car / noneï¼ˆauto=å…¼å®¹åˆ«åâ†’bipolarï¼›ä¸åšä»»ä½•"æ¨æ–­"ï¼‰ | âœ… |
| 1.4 é€šé“é€‰æ‹© | **æ˜¾å¼** include/exclude channelsï¼ˆç”¨äºå¤ç°GPUé€šé“åˆ—è¡¨ï¼›ä¸ç¡¬ç¼–ç "å»æ‰æœ«ç«¯Nä¸ªè§¦ç‚¹"ï¼‰ | âœ… |
| 1.5 é‡é‡‡æ · | Rippleâ†’1000Hz, FRâ†’2000Hz | âœ… |
| 1.6 æ»¤æ³¢ | Notch + å¯é€‰Bandpass, GPUåŠ é€Ÿæ”¯æŒ | âœ… |
| 1.7 é€šé“è´¨é‡æ£€æŸ¥ | z-score, æ–¹å·®, ä¼ªè¿¹æ ‡è®° | âœ… |
| **1.8 FilterBackendæ¶æ„** | **æŠ½è±¡æ¥å£ + CPU/GPUå®ç°åˆ†ç¦»** | âœ… **NEW** |

#### Phase 1 é‡æ„æ€»ç»“ï¼ˆ2026-01-30ï¼‰

**æ ¸å¿ƒæ”¹è¿›ï¼šæ¶ˆé™¤é‡å¤çš„æ¡ä»¶åˆ¤æ–­**

```python
# Before: æ•£è½å„å¤„çš„ GPU åˆ¤æ–­
if self.use_gpu and HAS_GPU:
    return self._apply_filters_gpu(...)  # 70+ lines
else:
    return self._apply_filters_cpu(...)  # 30+ lines

# After: åˆå§‹åŒ–æ—¶å†³å®šåç«¯ï¼Œè¿è¡Œæ—¶é›¶åˆ¤æ–­
self.filter_backend = GpuFilterBackend() if use_gpu else CpuFilterBackend()

def _apply_filters(self, data, sfreq):
    if self.notch_freqs:
        data = self.filter_backend.apply_notch(data, sfreq, self.notch_freqs)
    if self.bandpass:
        data = self.filter_backend.apply_bandpass(data, sfreq, *self.bandpass)
    return data
```

**åˆ é™¤çš„åºŸä»£ç **ï¼ˆé›¶ç ´åæ€§ï¼‰ï¼š
- âŒ `PreBipolarDetector` (15è¡Œ) - ç©ºå£³ç±»ï¼Œæ€»æ˜¯è¿”å› False
- âŒ `validate_against_gpu_results()` (12è¡Œ) - è¿è¡Œæ—¶æŠ›å¼‚å¸¸çš„åºŸå‡½æ•°
- âŒ `exclude_last_n` å‚æ•° - ä»æ‰€æœ‰ç±»å’Œå‡½æ•°ç­¾åä¸­ç§»é™¤

**æ–°å¢çš„æ¶æ„ç»„ä»¶**ï¼š

```python
# æŠ½è±¡æ¥å£
class FilterBackend:
    def apply_notch(data, sfreq, freqs): ...
    def apply_bandpass(data, sfreq, low, high): ...

# CPU å®ç°ï¼ˆscipy filtfiltï¼‰
class CpuFilterBackend(FilterBackend): ...

# GPU å®ç°ï¼ˆCuPy + chunked processingï¼‰
class GpuFilterBackend(FilterBackend):
    def __init__(self, chunk_sec=20.0): ...
    # è‡ªåŠ¨å¤„ç† GPU OOM - 20s chunks + reflect padding
```

**æ‰©å±•æ–°åç«¯çš„æ–¹æ³•**ï¼š

```python
# ä¾‹å¦‚ï¼šæ·»åŠ  Apple Metal æ”¯æŒ
class MetalFilterBackend(FilterBackend):
    def apply_notch(self, data, sfreq, freqs):
        # ä½¿ç”¨ PyTorch MPS æˆ– Metal Performance Shaders
        ...
    
    def apply_bandpass(self, data, sfreq, low, high):
        ...

# ä½¿ç”¨ï¼š
preprocessor = SEEGPreprocessor(
    use_gpu=False,  # ä¸ä½¿ç”¨ CUDA
    # æ‰‹åŠ¨æ›¿æ¢ backendï¼ˆé«˜çº§ç”¨æ³•ï¼‰
)
preprocessor.filter_backend = MetalFilterBackend()
```

**æ”¶ç›Š**ï¼š
- âœ… ä»£ç è¡Œæ•°: 1223 â†’ 1199 (-24è¡Œï¼Œè´¨é‡æå‡æ˜¾è‘—)
- âœ… GPU æ¡ä»¶åˆ†æ”¯: 4å¤„ â†’ 0å¤„
- âœ… å¯æ‰©å±•æ€§: æ·»åŠ æ–° backend (Metal/ROCm/OpenCL) åªéœ€å®ç° 2 ä¸ªæ–¹æ³•
- âœ… å¯æµ‹è¯•æ€§: æ¯ä¸ª backend å¯ç‹¬ç«‹å•å…ƒæµ‹è¯•
- âœ… é›¶ç ´åæ€§: æ‰€æœ‰å¤–éƒ¨è°ƒç”¨æ¥å£ä¿æŒå‘åå…¼å®¹

---

#### å…³é”®æŠ€æœ¯å†³ç­–ï¼ˆå†å²è®°å½•ï¼‰

- **ä¸å†çŒœ**ï¼šä¸å†æ ¹æ®"æŸäº›contactç¼ºå¤±"å»æ¨æ–­EDFæ˜¯å¦å·²åšbipolarï¼›é‚£æ˜¯é€šé“é€‰æ‹©ç­–ç•¥ï¼Œä¸æ˜¯é‡å‚è€ƒè¯æ®ã€‚
- **é‡å‚è€ƒç­–ç•¥ï¼ˆæ˜¾å¼ï¼‰**:
  - `'bipolar'`: åŒshaftç›¸é‚»è§¦ç‚¹å·®åˆ†ï¼›**å‘½åä¸ºæ˜ç¡®çš„`A1-A2`**ï¼Œé¿å…ä¸å•æé€šé“æ··æ·†
  - `'car'`: æ¯ä¸ªshaftå†…éƒ¨åšCAR
  - `'none'`: ä¿æŒEDFåŸå§‹å‚è€ƒï¼ˆå•æ/å‚è€ƒç”µæä½“ç³»ï¼‰ï¼Œä¸åšä»»ä½•æ¨æ–­
- **GPUé€šé“å·®å¼‚æ¥æºï¼ˆå·²ç¡®è®¤ï¼Œchengshuai/FC10477Qï¼‰**ï¼š
  - `*_gpu.npz` çš„ `chns_names` æ˜¯ EDF æ¸…æ´—åé€šé“çš„å­é›†ï¼›
  - å·®å¼‚ä¸»è¦æ¥è‡ª**é€šé“é€‰æ‹©/å‰”é™¤ç­–ç•¥**ï¼ˆä¾‹å¦‚æ¯ä¸ªshaftç¼ºå°‘æœ«ç«¯è‹¥å¹²contactï¼‰ï¼Œå¹¶ébipolaræ¨æ–­ä¾æ®ï¼›
  - è‹¥è¦å¤ç°GPUé€šé“é›†åˆï¼Œä½¿ç”¨ `include_channels=gpu['chns_names']`ï¼ˆæ˜¾å¼ï¼‰ã€‚

---

### æ¨¡å—2: src/hfo_detector.py âœ… å®Œæˆï¼ˆPhase 2 é‡æ„ 2026-01-31ï¼‰

| åŠŸèƒ½ | è¯´æ˜ | çŠ¶æ€ |
|------|------|------|
| 2.1 çº¯BQKç®—æ³• | åˆ é™¤ `mad_hysteresis` ç®—æ³•ï¼ˆ-200è¡Œä»£ç ï¼‰ | âœ… |
| 2.2 BQKDetectorç±» | å°è£… `bqk_utils.py`ï¼Œé¢„è®¡ç®—æ»¤æ³¢å™¨ç³»æ•° | âœ… |
| 2.3 å¤šå¸¦åŒ…ç»œ | å®½å¸¦åˆ†20Hzå­å¸¦ï¼ŒButterworth 3é˜¶æ»¤æ³¢ + Hilbert | âœ… |
| 2.4 å¹¶è¡ŒåŒ– | `joblib.Parallel` å¹¶è¡Œè®¡ç®—å­å¸¦åŒ…ç»œ | âœ… |
| 2.5 åŒé˜ˆå€¼æ£€æµ‹ | `rel_threshÃ—local_median` âˆ§ `abs_threshÃ—global_median` | âœ… |
| 2.6 äº‹ä»¶åˆå¹¶ç­›é€‰ | `merge_timeRanges` + `min_last` æŒç»­æ—¶é—´è¿‡æ»¤ | âœ… |
| 2.7 Ripple/FRåˆ†ç¦» | `band='ripple'/'fast_ripple'` | âœ… |

#### Phase 2 é‡æ„æ€»ç»“ï¼ˆ2026-01-31ï¼‰

**æ ¸å¿ƒæ”¹è¿›ï¼šå°è£… + å¹¶è¡ŒåŒ–ï¼ˆä½†æ³¨æ„é€‚ç”¨åœºæ™¯ï¼‰**

```python
# Before: åˆ†æ•£çš„å‡½æ•°è°ƒç”¨
env = bqk.return_hil_enve_norm(data, fs, freqband)  # å†…éƒ¨å¾ªç¯Kæ¬¡æ»¤æ³¢
events = bqk.find_high_enveTimes(env, ...)

# After: æ¸…æ™°çš„ç±»å°è£… + å¯é€‰å¹¶è¡Œ
detector = BQKDetector(sfreq=fs, freqband=(80,250), n_jobs=1)  # é»˜è®¤ä¸²è¡Œ
env = detector.compute_envelope(data)  # é¢„è®¡ç®—æ»¤æ³¢å™¨ç³»æ•°
events = detector.detect_events(data)  # ç«¯åˆ°ç«¯æ£€æµ‹
```

**åˆ é™¤çš„ä»£ç **ï¼ˆé›¶ç ´åæ€§ï¼Œ-348è¡Œï¼‰ï¼š
- âŒ `mad_hysteresis` ç®—æ³•åŠæ‰€æœ‰ç›¸å…³å‡½æ•°ï¼ˆ~200è¡Œï¼‰
- âŒ GPUç›¸å…³ä»£ç ï¼ˆ`cupy_hilbert`, `_HAS_CUPY`ï¼‰
- âŒ Ictalæ£€æµ‹ç›¸å…³ï¼ˆ`_detect_ictal_mask`, `_mad`, `_moving_average`, `_find_runs`ï¼‰

**æ€§èƒ½æµ‹è¯•ç»“æœ**ï¼ˆ2026-01-31, cuda_envï¼‰ï¼š

| åœºæ™¯ | n_jobs=1 | n_jobs=-1 | ç»“è®º |
|------|----------|-----------|------|
| å°æ•°æ® (8chÃ—10s) | 0.078s | 0.902s | âŒ å¹¶è¡Œæ…¢12x (è¿›ç¨‹å¼€é”€) |
| å¤§æ•°æ® (16chÃ—30s) | 0.457s | 1.100s | âŒ å¹¶è¡Œæ…¢2.4x |
| æ•°å€¼ä¸€è‡´æ€§ | - | diff=1.81e-10 | âœ… å®Œç¾ |

**å…³é”®å‘ç°ï¼ˆAmdahl's Lawé™·é˜±ï¼‰**ï¼š
```
å¹¶è¡Œå¼€é”€ = joblibè¿›ç¨‹åˆ›å»º (~500ms) + æ•°æ®åºåˆ—åŒ– (~200ms)
è®¡ç®—æ—¶é—´ = K Ã— (æ»¤æ³¢+Hilbert) â‰ˆ 0.078s (K=9, 8chÃ—10s)

å½“ è®¡ç®—æ—¶é—´ < å¹¶è¡Œå¼€é”€ â†’ ä¸²è¡Œæ›´å¿«
```

**å¹¶è¡ŒåŒ–é€‚ç”¨åœºæ™¯**ï¼š
- âœ… **é•¿æ—¶ç¨‹æ— chunk**ï¼š`chunk_sec=None` + å•æ–‡ä»¶>2åˆ†é’Ÿ + K>20
- âŒ **é»˜è®¤chunkedå¤„ç†**ï¼š30s chunk â†’ è®¡ç®— <200ms â†’ n_jobs=1 æ›´å¿«

**æ¨èé…ç½®**ï¼š

```python
# é»˜è®¤é…ç½®ï¼ˆæ¨èï¼‰ï¼šn_jobs=1
config = HFODetectionConfig(
    band='ripple',
    chunk_sec=30.0,  # åˆ†å—å¤„ç†
    n_jobs=1,        # â† ä¸²è¡Œé¿å…è¿›ç¨‹å¼€é”€
)

# å…¨æ–‡ä»¶å¤„ç†ï¼ˆç‰¹æ®Šåœºæ™¯ï¼‰ï¼š
config = HFODetectionConfig(
    chunk_sec=None,  # â† æ•´ä¸ªæ–‡ä»¶ä¸€æ¬¡æ€§å¤„ç†
    n_jobs=-1,       # â† å¯èƒ½æœ‰æ”¶ç›Šï¼ˆéœ€æµ‹è¯•ï¼‰
)
```

**æ”¶ç›Š**ï¼š
- âœ… ä»£ç : 632è¡Œ â†’ 284è¡Œ (-55%)
- âœ… ç®—æ³•: å•ä¸€BQKè·¯å¾„
- âœ… å°è£…: `BQKDetector` ç±»ï¼Œæ»¤æ³¢å™¨ç³»æ•°é¢„è®¡ç®—
- âœ… æ•°å€¼: ä¸åŸ `bqk_utils.py` è¯¯å·® <1e-9
- âš ï¸ å¹¶è¡Œ: **ä»…é•¿æ—¶ç¨‹åœºæ™¯æœ‰æ•ˆï¼Œé»˜è®¤åœºæ™¯åè€Œå˜æ…¢**

**å…³é”®æŠ€æœ¯å†³ç­–**:
- **ç®—æ³•çº¯åŒ–**: åªä¿ç•™BQKï¼Œåˆ é™¤æ‰€æœ‰éBQKä»£ç 
- **ç±»å°è£…**: `BQKDetector` é¢„è®¡ç®—æ»¤æ³¢å™¨ç³»æ•°ï¼ˆä¸å†æ¯chunké‡å¤ï¼‰
- **Chunkedå¤„ç†**: 30s chunk + 1s overlapï¼Œé¿å…å†…å­˜çˆ†ç‚¸
- **å¹¶è¡ŒåŒ–ç­–ç•¥**: é»˜è®¤ `n_jobs=1`ï¼ˆå®æµ‹æ›´å¿«ï¼‰ï¼Œé¿å…joblibå¼€é”€
- **åŒé˜ˆå€¼ç­–ç•¥**: `rel_thresh Ã— local_median` âˆ§ `abs_thresh Ã— global_median`

---

### æ¨¡å—3: src/group_event_analysis.py âœ… æ ¸å¿ƒé€»è¾‘å®Œæˆ

> **è®¾è®¡åŸåˆ™**ï¼šè¿™æ˜¯æ•´ä¸ªæµç¨‹çš„"è®¡ç®—ä¸­å¿ƒ"â€”â€”æ‰€æœ‰ä¸­é—´ç»“æœéƒ½ä»è¿™é‡Œäº§å‡ºï¼Œåç»­æ¨¡å—åªè¯»å–ã€‚

#### è¾“å…¥è§„èŒƒ

| è¾“å…¥ | æ¥æº | æ•°æ®ç»“æ„ |
|------|------|----------|
| é¢„å¤„ç†ç»“æœ | `preprocessing.py` | `PreprocessingResult` (data, sfreq, ch_names) |
| HFOäº‹ä»¶ | `hfo_detector.py` æˆ– `*_gpu.npz` | `Dict[ch_name â†’ np.ndarray (n,2)]` |
| æ‚£è€…çº§æ±‡æ€» | `_refineGpu.npz` | events_count (n_ch,), chns_names |
| æ ¸å¿ƒé€šé“ | `hist_meanX.npz` | pick_chns (8,) |
| äº‹ä»¶çª—å£ | `*_packedTimes.npy` | (n_events, 2) [start, end] ç§’ |

#### è¾“å‡ºè§„èŒƒ

| è¾“å‡ºæ–‡ä»¶ | å†…å®¹ | ä¸‹æ¸¸ç”¨æˆ· |
|----------|------|----------|
| `*_envCache_{band}_{ref}.npz` | envelope + (å¯é€‰x_band) + sfreq + ch_names | visualization (Fig1æ³¢å½¢) |
| `*_groupAnalysis.npz` | **è´¨å¿ƒ+lag+rank+baselineæ± å…ƒæ•°æ®ï¼ˆTFå¯é€‰ï¼‰** | visualization, network_analysis |

#### åŠŸèƒ½åˆ†è§£

| åŠŸèƒ½ | è¯´æ˜ | çŠ¶æ€ |
|------|------|------|
| 3.1 çª—å£æ„å»º | `build_windows_from_detections` | âœ… |
| 3.2 Envelopeç¼“å­˜ | `precompute_envelope_cache` | âœ… |
| 3.3 è´¨å¿ƒè®¡ç®— | `compute_centroid_matrix_from_envelope_cache` | âœ… |
| 3.4 Lag/Rank | `lag_rank_from_centroids` | âœ… |
| 3.5 TFè´¨å¿ƒ | `compute_tf_centroids`ï¼ˆwavelet+åŠ¨æ€åŸºçº¿ï¼‰ | âœ… |
| 3.6 ç»“æœå­˜å‚¨ | `save_group_analysis_results`, `load_group_analysis_results` | âœ… |
| 3.7 ä¸€é”®API | `compute_and_save_group_analysis` | âœ… |
| 3.7 é€šé“ç­›é€‰ | `select_core_channels_by_event_count` | âœ… |
| 3.8 éªŒè¯å‡½æ•° | `validate_*` ç³»åˆ— | âœ… |

**é…ç½®è¡¥å……ï¼ˆé»˜è®¤è¡Œä¸ºï¼‰**ï¼š
- `centroid_source='env'`ï¼šlag/rank é»˜è®¤åŸºäºåŒ…ç»œè´¨å¿ƒ
- `compute_tf_centroids=False`ï¼šTFè´¨å¿ƒé»˜è®¤ä¸è®¡ç®—ï¼ˆå¯é€‰å¼€å¯ï¼‰
- `save_bandpass=False`ï¼šx_band é»˜è®¤ä¸ä¿å­˜ï¼ˆä»…å¯è§†åŒ–éœ€è¦æ—¶å¼€å¯ï¼‰

**é˜¶æ®µæ€§ç»“è®ºï¼ˆ2026-01-16ï¼‰**:
- âœ… æ ¸å¿ƒé€šé“ç­›é€‰ï¼š`mean + 1*std` å¯å¤ç° `hist_meanX.npz` çš„ `pick_chns`
- âœ… packedTimes çª—å£é•¿åº¦ï¼šä» `packedTimes[:,1]-packedTimes[:,0]` æ¨æ–­
- âœ… Step1 éªŒè¯ï¼š`reference='bipolar'` + åˆ«åé€šé“ + GPUé€šé“è¿‡æ»¤ â†’ é«˜è¦†ç›–ç‡
- âœ… Step2-3 éªŒè¯ï¼š`eventsBool` 100% ä¸€è‡´ï¼›ç›¸å¯¹ lag è¾¾ ms çº§è¯¯å·®
- âœ… TFè´¨å¿ƒè®¡ç®—ï¼š`compute_tf_centroids` æ”¹ä¸º **wavelet+åŠ¨æ€åŸºçº¿**ï¼ˆéSTFTï¼‰ï¼Œé»˜è®¤å¯å…³é—­
- âœ… åŸºçº¿æ± ï¼š2sçª—/1sæ­¥é•¿ï¼Œæ’é™¤ictal+HFO+é«˜LL+é«˜Rippleï¼Œå­˜å…¥ `baseline_pool_starts/indices`
- âœ… ç»Ÿä¸€å­˜å‚¨ï¼š`save_group_analysis_results` + `load_group_analysis_results` å·²å®ç°
- âœ… ä¸€é”®APIï¼š`compute_and_save_group_analysis` å¯ä» EDF ä¸€ç«™å¼ç”Ÿæˆæ‰€æœ‰ä¸­é—´ç»“æœ

---

### æ¨¡å—4: src/network_analysis.py (å¼€å‘ä¸­)

> **æ ¸å¿ƒç›®æ ‡**ï¼šä» HFO ç¾¤ä½“äº‹ä»¶æ„å»ºä¸‹ä¸€ä»£ç™«ç—«ç½‘ç»œï¼Œå®ç° SOZ å®šä½ä¸ä¼ æ’­è·¯å¾„é¢„æµ‹ã€‚

---

#### 4.0 è®¾è®¡å“²å­¦ä¸æ‰¹åˆ¤æ€§å‰æ

**æ··åˆé—¨æ§ç­–ç•¥ (Hybrid Gating Strategy)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ç™«ç—«ç½‘ç»œæ„å»ºæµæ°´çº¿                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                        â”‚
â”‚  [èŠ‚ç‚¹æ± ]                                                               â”‚
â”‚      â”‚  â† å®½æ¾å‡†å…¥ï¼ˆRate + æ¡ä»¶æ¦‚ç‡ + ç—…ç†ç‰¹å¾ï¼‰                         â”‚
â”‚      â–¼                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  Co-activation Matrix (é—¨æ§ Gatekeeper)                     â”‚       â”‚
â”‚  â”‚  "åªæœ‰å…³ç³»å¤Ÿé“çš„èŠ‚ç‚¹ï¼Œæ‰é…æ‹¥æœ‰è¿è¾¹"                            â”‚       â”‚
â”‚  â”‚  â†’ å‰”é™¤å¶ç„¶éšæœºé‡åˆï¼Œå»ºç«‹ç½‘ç»œ"éª¨æ¶"                           â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                             â”‚                                          â”‚
â”‚                             â–¼                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  Lag Matrix (ç½—ç›˜ Compass)                                  â”‚       â”‚
â”‚  â”‚  "è°å…ˆè°åï¼Œå†³å®šè°æ˜¯é©±åŠ¨è€…ï¼Œè°æ˜¯è·Ÿéšè€…"                        â”‚       â”‚
â”‚  â”‚  â†’ åœ¨éª¨æ¶ä¸Šèµ‹äºˆæ–¹å‘ï¼Œæ³¨å…¥ç½‘ç»œ"è¡€æµ"                           â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                             â”‚                                          â”‚
â”‚                             â–¼                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  Physics Constraints (ç‰©ç†çº¦æŸ)                             â”‚       â”‚
â”‚  â”‚  â†’ å®¹ç§¯ä¼ å¯¼å‰”é™¤ (<10mm)                                     â”‚       â”‚
â”‚  â”‚  â†’ ä¼ æ’­é€Ÿåº¦éªŒè¯ (0.1-10 m/s ç”Ÿç†èŒƒå›´)                        â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                             â”‚                                          â”‚
â”‚                             â–¼                                          â”‚
â”‚  [åŠ æƒæœ‰å‘å›¾ G(V, E, W)]  â†’  å›¾è®ºæŒ‡æ ‡  â†’  SOZ/ä¼ æ’­è·¯å¾„                  â”‚
â”‚                                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ä¸ºä»€ä¹ˆä¸èƒ½äºŒé€‰ä¸€ï¼Ÿ**

| ç­–ç•¥ | å•ç‹¬ä½¿ç”¨çš„è‡´å‘½ç¼ºé™· |
|------|-------------------|
| ä»… Co-activation | æ— æ–¹å‘ä¿¡æ¯ï¼Œæ— æ³•åŒºåˆ† Source å’Œ Sink |
| ä»… Lag | å™ªå£°æ•æ„Ÿï¼Œå¶ç„¶é‡åˆçš„é€šé“å¯¹ä¼šäº§ç”Ÿéšæœºæ–¹å‘ |
| **æ··åˆ** | Co-activation é™å™ª â†’ Lag å®šå‘ï¼Œäº’è¡¥ |

---

#### 4.1 ç°æœ‰èµ„äº§ç›˜ç‚¹ (Asset Inventory)

**âœ… å·²æœ‰æ•°æ®ï¼ˆgroupAnalysis.npzï¼‰**

| æ•°æ® | å½¢çŠ¶ | ç‰©ç†æ„ä¹‰ | ç½‘ç»œç”¨é€” |
|------|------|----------|---------|
| `ch_names` | (n_ch,) | æ ¸å¿ƒé€šé“å | èŠ‚ç‚¹æ ‡è¯† |
| `coact_all_ch_names` | (n_all,) | **å…¨é€šé“å** | æ‰©å¤§èŠ‚ç‚¹æ±  |
| `coact_event_ratio` | (n_ch, n_ch) | å…±æ¿€æ´»æ¦‚ç‡ | **éª¨æ¶æ„å»º** |
| `coact_all_event_ratio` | (n_all, n_all) | **å…¨é€šé“å…±æ¿€æ´»** | æ‰©å¤§èŠ‚ç‚¹æ±  |
| `lag_raw` | (n_ch, n_events) | è´¨å¿ƒæ—¶é—´ï¼ˆç›¸å¯¹çª—å£èµ·ç‚¹ï¼‰ | **æ–¹å‘è®¡ç®—** |
| `events_bool` | (n_ch, n_events) | é€šé“å‚ä¸mask | äº‹ä»¶è¿‡æ»¤ |
| `event_windows` | (n_events, 2) | äº‹ä»¶çª—å£ [start, end] | æ—¶é—´åˆ†æ®µ |

**å…³é”®æ•°æ®ç»“æ„æ´å¯Ÿ**ï¼š

```python
# lag_raw å­˜å‚¨çš„æ˜¯æ¯é€šé“ç›¸å¯¹äºçª—å£èµ·ç‚¹çš„è´¨å¿ƒæ—¶é—´
# è¦è·å¾—é€šé“å¯¹ (i, j) åœ¨äº‹ä»¶ k ä¸­çš„æ—¶æ»ï¼š
lag_ij_k = lag_raw[i, k] - lag_raw[j, k]  # è´Ÿå€¼ = i é¢†å…ˆ j

# è¿™æ˜¯ç´§å‡‘å­˜å‚¨ï¼šO(n_ch Ã— n_events) vs O(n_chÂ² Ã— n_events)
# è¿è¡Œæ—¶è®¡ç®—å·®å€¼ï¼Œç©ºé—´æ¢æ—¶é—´
```

**âš ï¸ ç¼ºå¤±æ•°æ®ï¼ˆéœ€è¦æ‰©å±•ï¼‰**

| æ•°æ® | å½¢çŠ¶ | æ¥æº | ä¼˜å…ˆçº§ | ç”¨é€” |
|------|------|------|--------|------|
| `electrode_distance` | (n_all, n_all) | MNIåæ ‡è®¡ç®— | **Phase B é˜»å¡** | å®¹ç§¯ä¼ å¯¼å‰”é™¤ã€ä¼ æ’­é€Ÿåº¦éªŒè¯ |
| `hfo_type_per_event` | (n_ch, n_events) | æ£€æµ‹å™¨è¾“å‡º | **Phase B** | ç—…ç†åŠ æƒ (FR æ¯”ä¾‹) |
| `tissue_label` | (n_all,) | FreeSurfer | Phase C | ç°/ç™½è´¨è¿‡æ»¤ï¼ˆä¸ç¡¬å‰”é™¤ï¼‰ |
| `mni_coords` | (n_all, 3) | é…å‡†ç»“æœ | **Phase B é˜»å¡** | 3Då¯è§†åŒ–ã€è·ç¦»çŸ©é˜µ |
| `lead_field_matrix` | (n_ch, n_sources) | BEM å‰å‘å»ºæ¨¡ | Phase C | æºç©ºé—´ LFM æ¦‚ç‡æŠ•å½± |
| `sc_matrix` | (n_regions, n_regions) | HCP tractography | Phase C | SC-FC è€¦åˆå›¾ |

---

#### 4.2 èŠ‚ç‚¹ç­›é€‰ç­–ç•¥ (Node Selection) â€” ä»"ä¸‰å±‚å‡†å…¥"åˆ°"è°±èšç±»-ç‡åŠ æƒ"

**æ ¸å¿ƒé—®é¢˜**ï¼šå›¾è®ºç»Ÿè®¡åœ¨ $N=8$ æ—¶ç»Ÿè®¡æ•ˆåŠ›æä½ã€‚å¿…é¡»æ‰©å¤§èŠ‚ç‚¹æ± è‡³ 30-50 ä¸ªï¼Œä½†ä¸èƒ½æ— è„‘å †ç Œã€‚

##### 4.2.1 ä¸¤ç§ä¸»æµç­–ç•¥çš„è‡´å‘½ç¼ºé™·

| | Rate-based (å‘æ”¾ç‡ç­›é€‰) | Co-activation (å…±æ¿€æ´»ç­›é€‰) |
|---|---|---|
| **å‡è®¾** | å‘æ”¾ç‡è¶Šé«˜ = è‡´ç—«æ€§è¶Šé«˜ | åŒæ­¥æ”¾ç”µ = ç—…ç†ç½‘ç»œ |
| **ä¼˜åŠ¿** | $O(N)$ å¤æ‚åº¦ï¼Œç›´è§‚ | å¤©ç„¶å™ªå£°è¿‡æ»¤å™¨ï¼Œæ‹“æ‰‘ç›¸å…³ |
| **è‡´å‘½ç¼ºé™· 1** | **ç”Ÿç†æ€§ HFO æ··æ·†**ï¼šè§†è§‰/è¿åŠ¨çš®å±‚å’Œæµ·é©¬åœ¨ NREM æœŸé—´äº§ç”Ÿé«˜é¢‘ç‡ç”Ÿç†æ€§ HFOï¼Œè¢«è¯¯åˆ¤ä¸ºè‡´ç—«ç¶ | **Sink é™·é˜±**ï¼šè¢«åŠ¨å“åº”èŠ‚ç‚¹å› é¢‘ç¹è¢«é©±åŠ¨è€Œè¡¨ç°å‡ºæé«˜å…±æ¿€æ´»ç‡ï¼Œæ— æ³•åŒºåˆ† Source å’Œ Sink |
| **è‡´å‘½ç¼ºé™· 2** | **"æœ€å“äº®èŠ‚ç‚¹"è°¬è¯¯**ï¼šæœ€æ´»è·ƒçš„èŠ‚ç‚¹ä¸ä¸€å®šæ˜¯ Driverã€‚çœŸæ­£çš„"èµ·æå™¨"å¯èƒ½å‘æ”¾ç‡ä½ä½†åœ¨å…³é”®æ—¶åˆ»è§¦å‘å…¨ç½‘åŒæ­¥ | **é˜ˆå€¼æ•æ„Ÿæ€§**ï¼š20% æ˜¯ç»éªŒå€¼ï¼Œå¯¹é«˜åº¦å±€ç¶æ€§ç™«ç—«ï¼ˆå¾®å° FCDï¼‰å¯èƒ½æ¼åˆ¤ |
| **è‡´å‘½ç¼ºé™· 3** | **æ—¶é—´éå¹³ç¨³æ€§**ï¼šå—ç¡çœ å‘¨æœŸå’Œè¯ç‰©æµ“åº¦å½±å“ï¼ŒçŸ­æ—¶ç»Ÿè®¡é˜ˆå€¼ä¸ç¨³å®š | æ— æ³•æä¾›"å¼ºåº¦"ä¿¡æ¯ï¼Œä»…æä¾›"å­˜åœ¨æ€§" |

**ç»“è®º**ï¼šå¿…é¡»èåˆä¸¤è€… â€” ç”¨ Co-activation çš„æŠ—å™ªæ€§é”å®šç½‘ç»œæ ¸å¿ƒï¼Œç”¨ Rate çš„å¼ºåº¦ä¿¡æ¯åŒºåˆ† Source å’Œ Sinkã€‚

##### 4.2.2 æ¨èç­–ç•¥ï¼šæ—¶ç©ºçº¦æŸçš„è°±èšç±»-ç‡åŠ æƒç­›é€‰å™¨

> Spatially Constrained Spectral-Rate Filter

**ä¸ºä»€ä¹ˆç”¨è°±èšç±»è€Œä¸æ˜¯å›ºå®šé˜ˆå€¼ï¼Ÿ**

å›ºå®šé˜ˆå€¼ï¼ˆå¦‚ top 20%ï¼‰åœ¨æ‚£è€…é—´ä¸å…·æ³›åŒ–æ€§ â€” é«˜åº¦å±€ç¶çš„ FCD æ‚£è€…å’Œå¼¥æ¼«æ€§çš®å±‚å‘è‚²ä¸è‰¯æ‚£è€…çš„ç½‘ç»œè§„æ¨¡å¤©å·®åœ°åˆ«ã€‚è°±èšç±»åˆ©ç”¨æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µçš„ç‰¹å¾å€¼é—´éš™ï¼ˆEigengapï¼‰**è‡ªé€‚åº”åœ°**ç¡®å®šèšç±»æ•°ï¼Œæ¯”ä»»ä½•å›ºå®šé˜ˆå€¼éƒ½æ›´é²æ£’ã€‚

**ä¸‰æ­¥æµç¨‹**ï¼š

```
Step 1: æ—¶ç©ºçº¦æŸçš„å…±æ¿€æ´»å›¾
   A_co (nÃ—n) â†’ è·ç¦»æƒ©ç½š â†’ A_co_masked
                             â”‚
Step 2: è°±èšç±»å­å›¾æå–        â”‚
   L = D - A_co_masked       â”‚
   ç‰¹å¾åˆ†è§£ â†’ Eigengap       â”‚
   â†’ è¯†åˆ«ä¸»è¦ç°‡ (å‰”é™¤å­¤ç«‹ç‚¹)  â”‚
                             â”‚
Step 3: ç‡è°ƒåˆ¶çš„ä¸­å¿ƒæ€§åŠ æƒ     â”‚
   W_i = Î±Â·EigenCentrality(i) + (1-Î±)Â·f(Rate_i)
   â†’ æœ€ç»ˆèŠ‚ç‚¹é›†åˆ + æƒé‡
```

**Step 1 â€” æ„å»ºæ—¶ç©ºçº¦æŸçš„å…±æ¿€æ´»å›¾**ï¼š

```python
def build_spatial_coact_graph(
    coact_ratio: np.ndarray,         # (n_all, n_all) å…±æ¿€æ´»æ¦‚ç‡
    dist_matrix: Optional[np.ndarray] = None,  # (n_all, n_all) mm
    min_dist_mm: float = 5.0,        # å®¹ç§¯ä¼ å¯¼æƒ©ç½šè·ç¦»
) -> np.ndarray:
    """
    å¯¹å…±æ¿€æ´»çŸ©é˜µæ–½åŠ ç©ºé—´çº¦æŸï¼Œå‰”é™¤è¿‘è·ç¦»è™šå‡åŒæ­¥ã€‚

    ç‰©ç†ä¾æ®ï¼š
    - SEEG å®ç”µæä¼ æ„ŸåŠå¾„ ~3-5mm (è§¦ç‚¹ Ï†0.8mm, é•¿2mm)
    - <5mm çš„"é«˜åŒæ­¥"å¤šä¸ºç”µåœºç›´æ¥ä¼ å¯¼ï¼Œéçªè§¦ä¼ æ’­
    """
    A = coact_ratio.copy()
    np.fill_diagonal(A, 0)

    if dist_matrix is not None:
        close_mask = dist_matrix < min_dist_mm
        A[close_mask] = 0  # å¼ºåˆ¶æ–­å¼€è¿‘è·ç¦»è¾¹

    # å¯¹ç§°åŒ–ï¼ˆå–è¾ƒå°å€¼ï¼Œä¿å®ˆä¼°è®¡ï¼‰
    A = np.minimum(A, A.T)
    return A
```

**Step 2 â€” è°±èšç±»å­å›¾æå–**ï¼š

```python
from sklearn.cluster import SpectralClustering

def extract_network_clusters(
    A_co: np.ndarray,                 # æ—¶ç©ºçº¦æŸåçš„å…±æ¿€æ´»çŸ©é˜µ
    min_cluster_size: int = 3,        # æœ€å°ç°‡å¤§å°ï¼ˆ<3 è§†ä¸ºå™ªå£°ï¼‰
    n_clusters: Optional[int] = None, # None = è‡ªåŠ¨ Eigengap
) -> Tuple[np.ndarray, int]:
    """
    ä»å…±æ¿€æ´»çŸ©é˜µä¸­è‡ªé€‚åº”æå–ç½‘ç»œæ ¸å¿ƒç°‡ã€‚

    Returns:
        labels: (n,) èšç±»æ ‡ç­¾ï¼Œ-1 è¡¨ç¤ºè¢«å‰”é™¤çš„å­¤ç«‹/å¾®å°ç°‡
        n_clusters_found: å®é™…ç°‡æ•°
    """
    n = A_co.shape[0]

    if n_clusters is None:
        # Eigengap å¯å‘å¼ï¼šæ‹‰æ™®æ‹‰æ–¯çŸ©é˜µç‰¹å¾å€¼æœ€å¤§è·³è·ƒ
        D = np.diag(A_co.sum(axis=1))
        L = D - A_co
        k = min(20, n - 1)
        eigenvalues = np.sort(np.linalg.eigvalsh(L))[:k]
        gaps = np.diff(eigenvalues)
        n_clusters = int(np.argmax(gaps[1:])) + 2  # è·³è¿‡ç¬¬ä¸€ä¸ª(æ€»æ˜¯0)
        n_clusters = max(2, min(n_clusters, n // 3))

    sc = SpectralClustering(
        n_clusters=n_clusters,
        affinity='precomputed',
        assign_labels='kmeans',
        random_state=42,
    )
    labels = sc.fit_predict(A_co)

    # å‰”é™¤è¿‡å°çš„ç°‡ï¼ˆéç½‘ç»œæ€§ HFO æˆ–å™ªå£°ï¼‰
    for cl in np.unique(labels):
        if (labels == cl).sum() < min_cluster_size:
            labels[labels == cl] = -1

    return labels, n_clusters
```

**Step 3 â€” ç‡è°ƒåˆ¶çš„ä¸­å¿ƒæ€§åŠ æƒ**ï¼š

```python
import networkx as nx

def compute_node_weights(
    A_co: np.ndarray,              # å…±æ¿€æ´»çŸ©é˜µ
    rate_per_ch: np.ndarray,       # (n,) HFOå‘æ”¾ç‡ (events/min)
    cluster_labels: np.ndarray,    # (n,) è°±èšç±»æ ‡ç­¾
    alpha: float = 0.65,           # ç½‘ç»œå±æ€§ vs å‘æ”¾ç‡æƒè¡¡
) -> np.ndarray:
    """
    èåˆç½‘ç»œåœ°ä½ï¼ˆEigenCentralityï¼‰ä¸ç—…ç†æ´»è·ƒåº¦ï¼ˆRateï¼‰ã€‚

    W_i = Î± Â· EigenCentrality(i) + (1-Î±) Â· normalize(log(1+Rate_i))

    Î± å»ºè®® 0.6-0.7ï¼š
      - å€¾å‘ç½‘ç»œå±æ€§ï¼šHubèŠ‚ç‚¹æƒé‡é«˜
      - ä¿ç•™ç‡ä¿¡æ¯ï¼šåŒºåˆ† Source(ç‡é«˜ä¸”ç¨³å®š) å’Œ Sink(è¢«åŠ¨å“åº”)
    """
    n = len(rate_per_ch)
    weights = np.zeros(n, dtype=np.float64)

    valid = cluster_labels >= 0
    if valid.sum() < 3:
        return weights

    # EigenCentralityï¼ˆåœ¨å­å›¾ä¸Šè®¡ç®—ï¼‰
    G = nx.from_numpy_array(A_co[np.ix_(valid, valid)])
    try:
        ec = nx.eigenvector_centrality_numpy(G, weight='weight')
        ec_arr = np.array([ec[i] for i in range(valid.sum())])
    except nx.NetworkXError:
        ec_arr = np.ones(valid.sum()) / valid.sum()

    # Rateï¼ˆå¯¹æ•°å½’ä¸€åŒ–ï¼Œé¿å…æç«¯å€¼ä¸»å¯¼ï¼‰
    rates = rate_per_ch[valid]
    rates_log = np.log1p(rates)  # log(1+rate), é¿å… log(0)
    rates_norm = rates_log / (rates_log.max() + 1e-10)

    ec_norm = ec_arr / (ec_arr.max() + 1e-10)

    weights[valid] = alpha * ec_norm + (1 - alpha) * rates_norm
    return weights
```

##### 4.2.3 æ›¿ä»£æ•°æ®æ˜¾è‘—æ€§æ£€éªŒï¼ˆSurrogate Testingï¼‰

> å…±æ¿€æ´»çš„"ç»Ÿè®¡æ˜¾è‘—"ä¸ç­‰äº"ç‰©ç†çœŸå®"ã€‚å¿…é¡»éªŒè¯è§‚æµ‹åˆ°çš„å…±æ¿€æ´»æ˜¯å¦æ˜¾è‘—é«˜äºéšæœºã€‚

```python
def surrogate_significance_test(
    events_bool: np.ndarray,       # (n_ch, n_events) å‚ä¸mask
    n_surrogates: int = 200,       # æ›¿ä»£æ•°æ®é›†æ•°é‡
    p_threshold: float = 0.05,     # æ˜¾è‘—æ€§é˜ˆå€¼
) -> np.ndarray:
    """
    ç‹¬ç«‹å¾ªç¯å¹³ç§»å„é€šé“äº‹ä»¶åºåˆ—ç”Ÿæˆæ›¿ä»£æ•°æ®é›†ï¼Œ
    éªŒè¯çœŸå®å…±æ¿€æ´»æ˜¯å¦æ˜¾è‘—é«˜äºéšæœºé¢„æœŸã€‚

    Returns: (n_ch, n_ch) bool â€” æ˜¾è‘—æ€§ mask
    """
    n_ch, n_ev = events_bool.shape
    real_coact = (events_bool @ events_bool.T).astype(np.float64) / n_ev

    surr_counts = np.zeros((n_ch, n_ch), dtype=np.int64)
    rng = np.random.default_rng(42)

    for _ in range(n_surrogates):
        shifted = np.zeros_like(events_bool)
        for ci in range(n_ch):
            shift = rng.integers(0, n_ev)
            shifted[ci] = np.roll(events_bool[ci], shift)
        surr_coact = (shifted @ shifted.T).astype(np.float64) / n_ev
        surr_counts += (surr_coact >= real_coact).astype(np.int64)

    p_values = surr_counts.astype(np.float64) / n_surrogates
    return p_values < p_threshold
```

##### 4.2.4 å®Œæ•´èŠ‚ç‚¹ç­›é€‰ API

```python
def select_network_nodes(
    coact_ratio: np.ndarray,          # (n_all, n_all) å…±æ¿€æ´»æ¦‚ç‡
    rate_per_ch: np.ndarray,          # (n_all,) HFO rate (events/min)
    events_bool: Optional[np.ndarray] = None,  # ç”¨äºæ›¿ä»£æ•°æ®æ£€éªŒ
    dist_matrix: Optional[np.ndarray] = None,
    # è°±èšç±»å‚æ•°
    min_dist_mm: float = 5.0,
    min_cluster_size: int = 3,
    n_clusters: Optional[int] = None,  # None = Eigengap è‡ªåŠ¨
    # æƒé‡å‚æ•°
    alpha: float = 0.65,
    # æ›¿ä»£æ£€éªŒ
    n_surrogates: int = 200,
) -> Tuple[np.ndarray, np.ndarray]:
    """
    ä¸‰æ­¥æ··åˆç­›é€‰ï¼šç©ºé—´çº¦æŸ â†’ è°±èšç±» â†’ ç‡åŠ æƒã€‚

    Returns:
        selected_idx: (n_selected,) å…¥é€‰èŠ‚ç‚¹ç´¢å¼•
        node_weights: (n_selected,) èŠ‚ç‚¹æƒé‡
    """
    # Step 1: ç©ºé—´çº¦æŸ
    A_co = build_spatial_coact_graph(coact_ratio, dist_matrix, min_dist_mm)

    # Step 1.5: æ›¿ä»£æ•°æ®æ£€éªŒï¼ˆå¯é€‰ä½†æ¨èï¼‰
    if events_bool is not None:
        sig_mask = surrogate_significance_test(events_bool, n_surrogates)
        A_co[~sig_mask] = 0

    # Step 2: è°±èšç±»
    labels, _ = extract_network_clusters(A_co, min_cluster_size, n_clusters)

    # Step 3: ç‡è°ƒåˆ¶ä¸­å¿ƒæ€§åŠ æƒ
    weights = compute_node_weights(A_co, rate_per_ch, labels, alpha)

    selected = np.where(labels >= 0)[0]
    return selected, weights[selected]
```

##### 4.2.5 å¯è¡Œæ€§ä¸å·¥ç¨‹çº¦æŸ

**è®¡ç®—å¤æ‚åº¦**ï¼šè°±èšç±»çš„ç‰¹å¾åˆ†è§£ä¸º $O(N^3)$ï¼ŒSEEG é€šé“æ•° $N \approx 120$ï¼Œå®æµ‹è€—æ—¶ **< 10ms**ï¼Œå®Œå…¨å¯è¡Œã€‚

**Eigengap ä¸ç¨³å®šæ—¶çš„é€€åŒ–ç­–ç•¥**ï¼šå½“ Eigengap ä¸æ˜æ˜¾æ—¶ï¼ˆç‰¹å¾å€¼å¹³ç¼“ä¸‹é™ï¼‰ï¼Œæä¾› `n_clusters` æ‰‹åŠ¨è¦†ç›–é€‰é¡¹ã€‚ä¹Ÿå¯é€€åŒ–ä¸ºç®€å•é˜ˆå€¼ç­›é€‰ï¼š

```python
# é€€åŒ–æ–¹æ¡ˆï¼ˆå½“è°±èšç±»ç»“æœä¸ç†æƒ³æ—¶çš„ä¿åº•ç­–ç•¥ï¼‰
selected = np.where(rate_per_ch > min_rate)[0]  # ç‡ç­›é€‰
selected = selected[coact_ratio[selected][:, selected].sum(1) > min_coact]  # å…±æ¿€æ´»è¿‡æ»¤
```

**âš ï¸ å…³é”®çº¦æŸ**ï¼š
- âŒ ä¸è¦ä»…ç”¨ç™½è´¨æ ‡ç­¾å‰”é™¤ â€” ç°è´¨å¼‚ä½/è„‘å®¤å‘¨å›´ç»“èŠ‚ä½äºæ·±éƒ¨ç™½è´¨ä½†æ˜¯ HFO é«˜å‘åŒº
- âŒ ä¸è¦ç¡¬ç¼–ç é€šé“æ•° â€” è®©è°±èšç±»çš„ Eigengap å†³å®šç½‘ç»œè§„æ¨¡
- âŒ ä¸è¦å¿½ç•¥"æ²‰é»˜çš„å…±çŠ¯" â€” ä½å‘æ”¾ç‡ä½†é«˜æ¡ä»¶æ¦‚ç‡çš„ Sink èŠ‚ç‚¹è¢«è°±èšç±»è‡ªç„¶ä¿ç•™
- âœ… Eigengap ä¸ç¨³å®šæ—¶ï¼Œæä¾› `n_clusters` æ‰‹åŠ¨è¦†ç›–é€‰é¡¹

---

#### 4.3 éª¨æ¶æ„å»º (Skeleton Construction) â€” åŠ æƒæ— å‘å›¾

**è¾“å…¥**ï¼š`coact_all_event_ratio` (n_all, n_all)

**æ“ä½œ**ï¼š

```python
def build_skeleton(
    coact_ratio: np.ndarray,
    dist_matrix: Optional[np.ndarray] = None,
    min_coact: float = 0.10,         # å…±æ¿€æ´»é˜ˆå€¼
    min_dist_mm: float = 10.0,       # å®¹ç§¯ä¼ å¯¼å‰”é™¤è·ç¦»
) -> np.ndarray:
    """
    è¿”å›äºŒå€¼é‚»æ¥çŸ©é˜µ (éª¨æ¶)ã€‚
    """
    n = coact_ratio.shape[0]
    skeleton = coact_ratio > min_coact
    
    # ç‰©ç†çº¦æŸï¼šå‰”é™¤å®¹ç§¯ä¼ å¯¼
    if dist_matrix is not None:
        close_mask = dist_matrix < min_dist_mm
        skeleton[close_mask] = False
    
    # å¯¹è§’çº¿æ¸…é›¶
    np.fill_diagonal(skeleton, False)
    
    return skeleton.astype(np.float32)
```

**é˜ˆå€¼é€‰æ‹©å»ºè®®**ï¼š
- `min_coact = 0.10` (10%) â€” å®½æ¾èµ·ç‚¹ï¼Œåç»­å¯è°ƒ
- æˆ– Top 10% è¾¹ â€” ä¿æŒç½‘ç»œç¨€ç–æ€§
- **å¿…é¡»å¯é…ç½®**ï¼Œä¸åŒæ‚£è€…ç—…ç†å·®å¼‚å¤§

---

#### 4.4 æ–¹å‘æ³¨å…¥ (Direction Injection) â€” éª¨æ¶å‡çº§ä¸ºæœ‰å‘å›¾

**æ ¸å¿ƒæ”¹è¿›ï¼šç»Ÿè®¡é²æ£’æ€§**

> **æ‰¹åˆ¤**ï¼šç›´æ¥ç”¨ä¸­ä½æ•° Lag å®šå‘æ˜¯å±é™©çš„ã€‚å¤šå³°åˆ†å¸ƒï¼ˆç›´æ¥é€šè·¯ 5ms + é—´æ¥é€šè·¯ 25msï¼‰çš„ä¸­ä½æ•° 15ms åœ¨ç‰©ç†ä¸Šæ²¡æœ‰æ„ä¹‰ã€‚

**é²æ£’æ–¹å‘åˆ¤å®šæµç¨‹**ï¼š

```python
from scipy.stats import wilcoxon

def inject_direction(
    skeleton: np.ndarray,           # (n, n) éª¨æ¶
    lag_raw: np.ndarray,            # (n, n_events) è´¨å¿ƒæ—¶é—´
    events_bool: np.ndarray,        # (n, n_events) å‚ä¸mask
    min_events: int = 5,            # æœ€å°æ ·æœ¬é‡
    lag_thresh_ms: float = 5.0,     # é›¶æ»åé˜ˆå€¼
    consistency_thresh: float = 0.6, # æ–¹å‘ä¸€è‡´æ€§é˜ˆå€¼
    p_value_thresh: float = 0.05,   # æ˜¾è‘—æ€§é˜ˆå€¼
) -> Tuple[np.ndarray, np.ndarray]:
    """
    è¿”å›:
        adj_directed: (n, n) æœ‰å‘é‚»æ¥çŸ©é˜µï¼ŒA[i,j] = iâ†’j çš„æƒé‡
        edge_stats: dict åŒ…å«æ¯æ¡è¾¹çš„ç»Ÿè®¡ä¿¡æ¯
    """
    n = skeleton.shape[0]
    adj = np.zeros((n, n), dtype=np.float64)
    
    for i in range(n):
        for j in range(i+1, n):
            if not skeleton[i, j]:
                continue
            
            # æå–å…±åŒäº‹ä»¶çš„ lag
            mask = events_bool[i] & events_bool[j]
            if mask.sum() < min_events:
                continue
            
            lags = lag_raw[i, mask] - lag_raw[j, mask]  # è´Ÿ = i é¢†å…ˆ
            
            # === ç»Ÿè®¡æ£€éªŒ ===
            
            # 1. Wilcoxon æ£€éªŒï¼šLag æ˜¯å¦æ˜¾è‘—å¼‚äº 0ï¼Ÿ
            try:
                _, p_val = wilcoxon(lags)
            except ValueError:  # å…¨é›¶æˆ–æ ·æœ¬å¤ªå°‘
                continue
            
            if p_val > p_value_thresh:
                continue  # é›¶æ»ååŒæ­¥ï¼Œä¸å®šå‘
            
            # 2. æ–¹å‘ä¸€è‡´æ€§æ£€éªŒ
            median_lag = np.median(lags)
            if abs(median_lag) < lag_thresh_ms * 1e-3:
                continue  # å¤ªæ¥è¿‘é›¶ï¼Œä¸å®šå‘
            
            direction = np.sign(median_lag)
            consistency = np.mean(np.sign(lags) == direction)
            
            if consistency < consistency_thresh:
                continue  # æ–¹å‘å¤ªä¹±ï¼Œè§†ä¸ºæ¹æµ
            
            # 3. èµ‹äºˆæ–¹å‘
            if median_lag < 0:  # i é¢†å…ˆ j
                adj[i, j] = consistency
            else:              # j é¢†å…ˆ i
                adj[j, i] = consistency
    
    return adj
```

**å…³é”®ç»Ÿè®¡ä¿æŠ¤**ï¼š

| æ£€éªŒ | ç›®çš„ | å¤±è´¥å¤„ç† |
|------|------|---------|
| Wilcoxon | Lag â‰  0ï¼Ÿ | ä¸å®šå‘ï¼ˆè§†ä¸ºåŒæ­¥ï¼‰ |
| ä¸€è‡´æ€§ | æ–¹å‘ç¨³å®šï¼Ÿ | ä¸å®šå‘ï¼ˆè§†ä¸ºæ¹æµï¼‰ |
| æ ·æœ¬é‡ | n â‰¥ 5ï¼Ÿ | ä¸å»ºè¾¹ï¼ˆæ•°æ®ä¸è¶³ï¼‰ |

---

#### 4.5 æƒé‡å®šä¹‰ (Weight Definition) â€” å¤šç»´å¤åˆæƒé‡

> å•ä¸€æƒé‡æ— æ³•æ•æ‰è‡´ç—«ç½‘ç»œçš„å¤æ‚æ€§ã€‚å¿…é¡»èåˆå› æœæ€§ã€ç¨³å®šæ€§ä¸ç—…ç†ç‰¹å¼‚æ€§ã€‚

##### 4.5.1 ä¸‰ç»´æƒé‡æ¨¡å‹

$$W_{ij} = \underbrace{\text{Coact}_{ij} \times \text{Consistency}_{ij}}_{\text{Causalityï¼ˆå› æœæ€§ï¼‰}} \times \underbrace{(1 - \text{CV}_{time}^{ij})}_{\text{Stabilityï¼ˆç¨³å®šæ€§ï¼‰}} \times \underbrace{\left(1 + \alpha \cdot \frac{N_{FR}^{ij}}{N_{total}^{ij}}\right)}_{\text{Pathologyï¼ˆç—…ç†æ€§ï¼‰}}$$

| ç»´åº¦ | å®šä¹‰ | æ•°æ®æ¥æº | Phase |
|------|------|----------|-------|
| **Causality** | $\text{Coact}_{ij} \times \text{Consistency}_{ij}$ â€” å…±æ¿€æ´»æ¦‚ç‡ Ã— æ–¹å‘ä¸€è‡´æ€§ | `coact_ratio` + `lag_raw` | **A (ç«‹å³å¯åš)** |
| **Stability** | $1 - \text{CV}(\text{Connectivity}(t))$ â€” è¿æ¥çš„æ—¶é—´é²æ£’æ€§ | `event_windows` æŒ‰æ—¶é—´çª—åˆ‡ç‰‡ | **A (ç«‹å³å¯åš)** |
| **Pathology** | $1 + \alpha \cdot \frac{N_{FR}}{N_{total}}$ â€” Fast Ripple æ¯”ä¾‹åŠ æƒ | `hfo_type_per_event` | **B (éœ€åˆ†ç±»æ•°æ®)** |

##### 4.5.2 Stabilityï¼ˆç¨³å®šæ€§ï¼‰ç»´åº¦ â€” æ—¶é—´é²æ£’æ€§

**æ ¸å¿ƒæ€æƒ³**ï¼šç™«ç—«ç½‘ç»œåº”å…·æœ‰åˆ»æ¿æ€§ï¼ˆStereotypicalï¼‰ï¼Œéšæœºå‡ºç°çš„è¿æ¥æ˜¯å™ªå£°ã€‚

```python
def compute_stability_weights(
    lag_raw: np.ndarray,           # (n_ch, n_events) è´¨å¿ƒæ—¶é—´
    events_bool: np.ndarray,       # (n_ch, n_events) å‚ä¸mask
    event_times: np.ndarray,       # (n_events,) äº‹ä»¶æ—¶é—´æˆ³
    window_sec: float = 300.0,     # 5åˆ†é’Ÿæ—¶é—´çª—
    min_windows: int = 3,          # æœ€å°‘çª—å£æ•°
) -> np.ndarray:
    """
    è®¡ç®—æ¯æ¡è¾¹åœ¨å¤šä¸ªæ—¶é—´çª—å†…çš„è¿æ¥æ–¹å‘ä¸€è‡´æ€§ã€‚
    
    Stability = 1 - CV(consistency_per_window)
    é«˜ç¨³å®šæ€§ = å›ºå®šçš„ç—…ç†é€šè·¯ï¼›ä½ç¨³å®šæ€§ = ç¬æ€å™ªå£°
    """
    n_ch = lag_raw.shape[0]
    stability = np.full((n_ch, n_ch), np.nan)
    
    # æŒ‰æ—¶é—´çª—åˆ‡ç‰‡
    t_min, t_max = event_times.min(), event_times.max()
    edges = np.arange(t_min, t_max, window_sec)
    if len(edges) < min_windows:
        return np.ones((n_ch, n_ch))  # æ•°æ®ä¸å¤Ÿï¼Œé€€åŒ–ä¸ºæƒé‡1
    
    window_consistencies = []
    for t_start in edges:
        t_end = t_start + window_sec
        win_mask = (event_times >= t_start) & (event_times < t_end)
        if win_mask.sum() < 5:
            continue
        
        # æ¯ä¸ªæ—¶é—´çª—å†…è®¡ç®—æ–¹å‘ä¸€è‡´æ€§
        cons = np.zeros((n_ch, n_ch))
        for i in range(n_ch):
            for j in range(i+1, n_ch):
                both = events_bool[i, win_mask] & events_bool[j, win_mask]
                if both.sum() < 3:
                    continue
                lags = lag_raw[i, win_mask][both] - lag_raw[j, win_mask][both]
                med = np.median(lags)
                cons[i, j] = np.mean(np.sign(lags) == np.sign(med))
                cons[j, i] = cons[i, j]
        window_consistencies.append(cons)
    
    if len(window_consistencies) < min_windows:
        return np.ones((n_ch, n_ch))
    
    stacked = np.stack(window_consistencies)
    mean_cons = np.nanmean(stacked, axis=0)
    std_cons = np.nanstd(stacked, axis=0)
    cv = np.where(mean_cons > 0, std_cons / mean_cons, 1.0)
    stability = 1.0 - np.clip(cv, 0, 1)
    
    return stability
```

##### 4.5.3 Pathologyï¼ˆç—…ç†æ€§ï¼‰ç»´åº¦ â€” é¢‘ç‡ç‰¹å¼‚æ€§

**è®¾è®¡ç†ç”±**ï¼ˆå‚è€ƒæ–‡çŒ®ï¼šSpikewHFOæ›´é‡è¦.pdfï¼‰ï¼š
- å åŠ  HFO çš„ Spike æ¯”å•çº¯ Spike æ›´èƒ½å®šä½ SOZ
- Fast Ripple æ¯” Ripple æ›´å…·ç—…ç†ç‰¹å¼‚æ€§
- ç»™é«˜ç—…ç†æ€§ä¼ æ’­äº‹ä»¶æ›´é«˜æŠ•ç¥¨æƒ

**Phase Aï¼ˆç«‹å³å¯åšï¼‰**ï¼šç”¨ Coact Ã— Consistency Ã— Stability ä¸‰ç»´æƒé‡

**Phase Bï¼ˆéœ€ FR åˆ†ç±»æ•°æ®åï¼‰**ï¼šåŠ å…¥ $(1 + \alpha \cdot FR_{ratio})$ å› å­ï¼Œ$\alpha$ å»ºè®® 0.5-2.0

##### 4.5.4 è¿›é˜¶æ–¹å‘ï¼šé¢‘è°±å› æœæ€§ï¼ˆPhase C ç ”ç©¶å‰æ²¿ï¼‰

> ç”¨é¢‘è°±æ ¼å…°æ°å› æœ (Spectral GC) æˆ–åå®šå‘ç›¸å¹² (PDC) æ›¿ä»£ Lag-based å› æœæ¨æ–­ã€‚

$$W_{ij}^{advanced} = \underbrace{\text{PDC}_{ij}(f_{HFO})}_{\text{é¢‘åŸŸå› æœ}} \times \underbrace{(1 - \text{CV}_{time})}_{\text{ç¨³å®šæ€§}} \times \underbrace{\frac{SC_{ij}}{SC_{max}}}_{\text{è§£å‰–å…ˆéªŒ}} \times \underbrace{\text{PathScore}_i}_{\text{èŠ‚ç‚¹ç—…ç†åˆ†}}$$

**ä¸ºä»€ä¹ˆåˆ—ä¸º Phase C**ï¼šPDC éœ€è¦æ¨¡å‹é˜¶æ•°é€‰æ‹©ï¼ˆAIC/BICï¼‰ã€å¹³ç¨³æ€§æ£€éªŒã€$O(N^2 \times T \times p)$ è®¡ç®—ã€‚å¯¹ 50 é€šé“ Ã— 2h æ•°æ®è™½ç„¶å¯è¡Œä½†è°ƒå‚å¤æ‚ã€‚å…ˆç”¨ Lag-based æ–¹æ³•éªŒè¯æ•´ä½“æµç¨‹ï¼Œå†è€ƒè™‘æ›¿æ¢ä¸º PDCã€‚

---

#### 4.6 å›¾è®ºæŒ‡æ ‡è®¡ç®— (Metric Calculation)

**ä½¿ç”¨ `networkx` åº“**ï¼š

| æŒ‡æ ‡ | å…¬å¼ | ä¸´åºŠæ„ä¹‰ |
|------|------|---------|
| **Net Outflow Index** | $\frac{OutDegree - InDegree}{OutDegree + InDegree}$ | **SOZ å®šä½**ï¼šå€¼æ¥è¿‘ +1 = Source |
| **Outflow Volatility** | $\text{Var}(\text{NetOutflow}_t)$ | çœŸæ­£ SOZ å¾€å¾€å‘ä½œå‰çªç„¶çˆ†å‘ |
| **Local Efficiency** | $E_{loc}(i) = \frac{1}{k_i(k_i-1)} \sum_{j,h \in N_i} \frac{1}{d_{jh}}$ | è‡´ç—«ç¶çš„ç´§å¯†ç¨‹åº¦ |
| **Shortest Path Tree** | ä» Source å‡ºå‘çš„æœ€çŸ­è·¯å¾„ | ä¼ æ’­è·¯å¾„é¢„æµ‹ |

```python
import networkx as nx

def compute_network_metrics(adj: np.ndarray, ch_names: List[str]) -> Dict:
    """
    è®¡ç®—æ ¸å¿ƒå›¾è®ºæŒ‡æ ‡ã€‚
    """
    G = nx.DiGraph()
    n = adj.shape[0]
    
    for i in range(n):
        for j in range(n):
            if adj[i, j] > 0:
                G.add_edge(ch_names[i], ch_names[j], weight=adj[i, j])
    
    metrics = {}
    
    # Net Outflow Index
    for node in G.nodes():
        out_deg = G.out_degree(node, weight='weight')
        in_deg = G.in_degree(node, weight='weight')
        total = out_deg + in_deg
        metrics[f'{node}_outflow'] = (out_deg - in_deg) / total if total > 0 else 0
    
    # Local Efficiency (éœ€è¦è½¬æ— å‘å›¾)
    G_undirected = G.to_undirected()
    metrics['local_efficiency'] = nx.local_efficiency(G_undirected)
    
    # Betweenness Centrality
    metrics['betweenness'] = nx.betweenness_centrality(G, weight='weight')
    
    return metrics
```

---

#### 4.7 å…³é”®é™·é˜±ä¸é˜²æŠ¤ (Critical Pitfalls)

**é™·é˜±1ï¼šå®¹ç§¯ä¼ å¯¼çš„å¹½çµ (Volume Conduction)**

| ç°è±¡ | ç‰©ç†è·ç¦» <10mmï¼ŒLag â‰ˆ 0ï¼ŒCo-activation æé«˜ |
|------|-------------------------------------------|
| åŸå›  | ç”µåœºç›´æ¥ä¼ å¯¼ï¼Œéç¥ç»å…ƒä¼ æ’­ |
| å±å®³ | ç½‘ç»œè¢«æ— æ„ä¹‰çŸ­è¾¹ä¸»å¯¼ |
| **é˜²æŠ¤** | å¼ºåˆ¶å‰”é™¤ `dist_matrix < 10mm` çš„è¾¹ |
| **åå‘åˆ©ç”¨** | ä¿ç•™å±€éƒ¨è¿æ¥å¼ºåº¦ä½œä¸º "Local Recruitment Score" |
| **é›¶æ»åé™·é˜±** | æ·±éƒ¨å¼ºæºè¢«ä¸¤ä¸ªè¿œè·ç”µæåŒæ—¶è®°å½• â†’ é«˜åŒæ­¥ä½†é›¶å»¶è¿Ÿ<br>å¿…é¡»ç”¨ PLI/wPLIï¼ˆå¯¹é›¶æ»åä¸æ•æ„Ÿï¼‰æˆ– Wilcoxon æ£€éªŒè¿‡æ»¤ |

**é™·é˜±2ï¼šé‡‡æ ·åå·® (Sampling Bias)**

| ç°è±¡ | SEEG ä»…è¦†ç›–ä¸åˆ° 1% çš„è„‘ä½“ç§¯ |
|------|------------------------------|
| å±å®³ | çœŸæ­£çš„æºåœ¨æœªé‡‡æ ·åŒºï¼Œä¸­ç»§ç«™è¢«è¯¯åˆ¤ä¸ºæº |
| **é˜²æŠ¤** | ç»“è®ºå¿…é¡»è°¨æ…ï¼š<br>"åœ¨è¢«ç›‘æµ‹çš„ç½‘ç»œä¸­ï¼ŒèŠ‚ç‚¹ X è¡¨ç°å‡ºæºçš„ç‰¹å¾" |

**é™·é˜±3ï¼šä¸­ä½æ•°é™·é˜± (The Median Trap)**

| ç°è±¡ | Lag åˆ†å¸ƒå¤šå³°ï¼ˆç›´æ¥é€šè·¯ 5ms + é—´æ¥é€šè·¯ 25msï¼‰ |
|------|-------------------------------------------|
| å±å®³ | ä¸­ä½æ•° 15ms åœ¨ç‰©ç†ä¸Šä¸å­˜åœ¨ |
| **é˜²æŠ¤** | å•å³°æ€§æ£€éªŒ (Hartigan's dip test) æˆ–æ–¹å·®æ£€æŸ¥<br>é«˜æ–¹å·®è¾¹æ ‡è®°ä¸º "Unstable Connection"ï¼Œé™ä½æƒé‡ |

**é™·é˜±4ï¼šé™æ€ç½‘ç»œçš„å±€é™**

| ç°è±¡ | 24å°æ—¶å¹³å‡å›¾æŠ¹æ€æ—¶é—´ç»´åº¦ |
|------|-------------------------|
| å±å®³ | é—´æ­‡æ€§å–·å‘çš„ SOZ è¢«æŒç»­æ´»è·ƒçš„ä¸­ç»§ç«™æ©ç›– |
| **è¿›é˜¶æ–¹å‘** | åŠ¨æ€åˆ‡ç‰‡ï¼šæ¯ 5 åˆ†é’Ÿæˆ–æ¯ 100 äº‹ä»¶è®¡ç®—ä¸€æ¬¡<br>æ¯”è¾ƒ Pre-ictal vs Interictal ç½‘ç»œæ‹“æ‰‘ |

**é™·é˜±5ï¼šç”Ÿç†æ€§ HFO æ··æ·† (Physiological HFO Contamination)** ğŸ”´ æ–°å¢

| ç°è±¡ | è§†è§‰/è¿åŠ¨çš®å±‚å’Œæµ·é©¬åœ¨ NREM æœŸé—´äº§ç”Ÿé«˜å‘æ”¾ç‡ç”Ÿç†æ€§ HFO |
|------|--------------------------------------------------|
| å±å®³ | åŠŸèƒ½åŒºè¢«è¯¯åˆ¤ä¸ºè‡´ç—«ç¶ â†’ æ‰‹æœ¯å¯¼è‡´åŠŸèƒ½ç¼ºæŸ |
| **é˜²æŠ¤** | è°±èšç±» + å…±æ¿€æ´»è¿‡æ»¤ â€” ç”Ÿç†æ€§ HFO å¾€å¾€æ˜¯å­¤ç«‹çš„å±€éƒ¨åŠŸèƒ½æŸ±æ´»åŠ¨ï¼Œä¸å½¢æˆå¤§å°ºåº¦åŒæ­¥ç½‘ç»œ<br>Stability æƒé‡ â€” ç”Ÿç†æ€§ HFO æ˜¯ä»»åŠ¡/çŠ¶æ€ç›¸å…³çš„ç¬æ€ï¼Œç—…ç†æ€§æ›´æŒç»­ |
| **è¡¥å……** | ç»“åˆ Spike-HFO å…±ç°ç‰¹å¾ï¼šå åŠ  Spike çš„ HFO ç—…ç†ç‰¹å¼‚æ€§æ›´é«˜ |

**é™·é˜±6ï¼šSink/Source åè½¬ (Sink Trap)** ğŸ”´ æ–°å¢

| ç°è±¡ | SOZ åœ¨å‘ä½œé—´æœŸå¯èƒ½è¡¨ç°ä¸º Sinkï¼ˆè¢«æŠ‘åˆ¶ï¼‰ï¼Œå‘ä½œæœŸè½¬ä¸º Source |
|------|------------------------------------------------------|
| å±å®³ | ä»…åˆ†æå‘ä½œé—´æœŸæ•°æ®ä¼šå°† SOZ è¯¯åˆ¤ä¸º"æ¥æ”¶èŠ‚ç‚¹" |
| **é˜²æŠ¤** | å¿…é¡»ç»“åˆ Ictal æ•°æ®éªŒè¯ï¼šå¯»æ‰¾"é—´æœŸ Sink â†’ å‘ä½œæœŸ Source"çš„åŠ¨æ€åè½¬èŠ‚ç‚¹<br>è¿™ç§åè½¬æœ¬èº«å°±æ˜¯ EZ çš„"æŒ‡çº¹"ç‰¹å¾ |
| **æŒ‡æ ‡** | $\Delta \text{Outflow} = \text{Outflow}_{ictal} - \text{Outflow}_{interictal}$ â€” åè½¬å¹…åº¦æœ€å¤§çš„èŠ‚ç‚¹ |

**é™·é˜±7ï¼šSEEG è¡Œæ³¢å‡è®¾å¤±æ•ˆ (Traveling Wave Caveat)** ğŸ”´ æ–°å¢

| ç°è±¡ | HFO/IED åœ¨çš®å±‚ä¸Šè¡¨ç°ä¸ºè¡Œæ³¢ï¼ˆTraveling Wavesï¼‰ |
|------|---------------------------------------------|
| å±å®³ | åœ¨ Grid ç”µæä¸Šå¯ç›´æ¥æ‹Ÿåˆæ³¢å³°æ¢¯åº¦åœºè®¡ç®—ä¼ æ’­é€Ÿåº¦çŸ¢é‡<br>**ä½† SEEG æ˜¯æ£’çŠ¶æ·±éƒ¨ç”µæ**ï¼Œç©¿è¿‡ä¸åŒçš®å±‚å±‚çº§ï¼Œ2D å¹³é¢æ³¢å‡è®¾å¤±æ•ˆ |
| **é˜²æŠ¤** | åœ¨ SEEG ä¸­å¿…é¡»æ²¿ç”µæè½´å‘ï¼ˆAxialï¼‰å’Œè·¨ç”µæï¼ˆCross-electrodeï¼‰åˆ†åˆ«è®¡ç®—å»¶è¿Ÿ<br>ä¸å¯ç›²ç›®æ‹Ÿåˆå¹³é¢æ³¢ |
| **æ–¹å‘åè½¬** | IED ä¼ æ’­æ–¹å‘é€šå¸¸**æŒ‡å‘**è‡´ç—«ç¶ï¼ˆSink ç‰¹å¾ï¼‰<br>Ictal Discharge é€šå¸¸**èƒŒç¦»**è‡´ç—«ç¶ä¼ æ’­<br>è¿™ä¸€æ–¹å‘åè½¬æ˜¯é‡è¦çš„å®šä½ç‰¹å¾ |

---

#### 4.8 ä¸‰é˜¶æ®µå®æ–½è·¯çº¿å›¾ (Three-Phase Roadmap)

> "Theory and practice sometimes clash. Theory loses. Every single time." â€” å…ˆç”¨ç°æœ‰æ•°æ®è·‘é€šå…¨æµç¨‹ï¼Œå†é€æ­¥åŠ å…¥é«˜çº§ç‰¹å¾ã€‚

##### Phase Aï¼šChannel-Scale MVPï¼ˆæ•°æ®å·²å°±ç»ªï¼Œç«‹å³å¯åšï¼‰

| Step | ä»»åŠ¡ | è¾“å…¥ | è¾“å‡º | æ–°å¢ä¾èµ– | çŠ¶æ€ |
|------|------|------|------|----------|------|
| A.1 | è°±èšç±»èŠ‚ç‚¹ç­›é€‰ | `coact_all_event_ratio`, `rate` | `selected_nodes`, `node_weights` | `sklearn` | â¬œ |
| A.2 | æ›¿ä»£æ•°æ®æ˜¾è‘—æ€§æ£€éªŒ | `events_bool` | `sig_mask` | â€” | â¬œ |
| A.3 | éª¨æ¶æ„å»ºï¼ˆæ— è·ç¦»çº¦æŸï¼‰ | `coact_ratio` | `skeleton` (æ— å‘) | â€” | â¬œ |
| A.4 | æ–¹å‘æ³¨å…¥ï¼ˆWilcoxon+ä¸€è‡´æ€§ï¼‰ | `skeleton`, `lag_raw` | `adj_directed` | `scipy.stats` | â¬œ |
| A.5 | Stability æƒé‡ | `lag_raw`, `event_windows` | `stability_matrix` | â€” | â¬œ |
| A.6 | å¤åˆæƒé‡è®¡ç®— | `adj`, `coact`, `stability` | `adj_weighted` | â€” | â¬œ |
| A.7 | å›¾è®ºæŒ‡æ ‡ | `adj_weighted` | `metrics_dict` | `networkx` | â¬œ |
| A.8 | 2D ç½‘ç»œæ‹“æ‰‘å›¾ | `metrics` | `network_plot.png` | `matplotlib` | â¬œ |

**Phase A çš„äº¤ä»˜ç‰©**ï¼šä¸€ä¸ªå®Œæ•´çš„ Channel-scale æœ‰å‘åŠ æƒç™«ç—«ç½‘ç»œï¼ŒåŒ…å« Net Outflow æ’åã€‚

##### Phase Bï¼šChannel-Scale + Geometryï¼ˆéœ€ MNI åæ ‡ï¼‰

| Step | ä»»åŠ¡ | è¾“å…¥ | è¾“å‡º | é˜»å¡æ¡ä»¶ | çŠ¶æ€ |
|------|------|------|------|----------|------|
| B.0 | ç”µæåæ ‡è·å– | MNI é…å‡†ç»“æœ | `mni_coords.npy`, `dist_matrix.npy` | **éœ€ä¸´åºŠæ•°æ®** | â¬œ |
| B.1 | ç©ºé—´çº¦æŸéª¨æ¶ | `dist_matrix`, `coact_ratio` | `skeleton_spatial` | B.0 | â¬œ |
| B.2 | å®¹ç§¯ä¼ å¯¼å‰”é™¤ | `dist_matrix < 10mm` | `skeleton_clean` | B.0 | â¬œ |
| B.3 | ä¼ æ’­é€Ÿåº¦éªŒè¯ | `dist_matrix`, `lag_raw` | `velocity_map` (0.1-10 m/s) | B.0 | â¬œ |
| B.4 | ç—…ç†åŠ æƒï¼ˆFR æ¯”ä¾‹ï¼‰ | `hfo_type_per_event` | `pathology_weight` | **éœ€ FR åˆ†ç±»** | â¬œ |
| B.5 | 3D è„‘å›¾ | `metrics`, `mni_coords` | `outflow_brain_3d.html` | B.0 | â¬œ |
| B.6 | Ictal vs Interictal å¯¹æ¯” | `event_windows`, `seizure_onsets` | `delta_outflow` | â€” | â¬œ |

**Phase B çš„äº¤ä»˜ç‰©**ï¼šç‰©ç†çº¦æŸåçš„ç½‘ç»œ + 3D å¯è§†åŒ– + Sink/Source åè½¬åˆ†æã€‚

##### Phase Cï¼šSource-Scale ç ”ç©¶å‰æ²¿ï¼ˆéœ€å½±åƒå­¦æµæ°´çº¿ï¼‰

| Step | ä»»åŠ¡ | è¾“å…¥ | é˜»å¡æ¡ä»¶ | çŠ¶æ€ |
|------|------|------|----------|------|
| C.1 | å‰å‘æ¨¡å‹(BEM) | FreeSurfer è¾“å‡º, ç”µæåæ ‡ | éœ€ MRI åˆ†å‰² + é…å‡† | â¬œ |
| C.2 | å¯¼è”åœºçŸ©é˜µ(LFM) | BEM æ¨¡å‹ | C.1 | â¬œ |
| C.3 | LFM æ¦‚ç‡æŠ•å½± | `LFM`, `channel_metrics` | C.2 | â¬œ |
| C.4 | SC-FC è€¦åˆå›¾ | HCP tractography | éœ€ DWI æ•°æ® | â¬œ |
| C.5 | PDC/é¢‘è°±æ ¼å…°æ° | åŸå§‹æ—¶é—´åºåˆ— | è®¡ç®—å¯†é›† | â¬œ |
| C.6 | NMM éªŒè¯ | è¿æ¥çŸ©é˜µ | ç‹¬ç«‹ç ”ç©¶è¯¾é¢˜ | â¬œ |

**Phase C çš„äº¤ä»˜ç‰©**ï¼šæºç©ºé—´çº§åˆ«çš„ç—…ç†ç½‘ç»œé‡æ„ï¼ˆç ”ç©¶è®ºæ–‡çº§åˆ«ï¼‰ã€‚

---

**æ ¸å¿ƒ API è®¾è®¡**ï¼š

```python
# src/network_analysis.py

@dataclass
class NetworkResult:
    """ç™«ç—«ç½‘ç»œåˆ†æç»“æœã€‚"""
    adj: np.ndarray              # (n_selected, n_selected) æœ‰å‘åŠ æƒé‚»æ¥çŸ©é˜µ
    node_names: List[str]        # èŠ‚ç‚¹é€šé“å
    node_weights: np.ndarray     # (n_selected,) èŠ‚ç‚¹æƒé‡ (EigenCentrality Ã— Rate)
    metrics: Dict[str, Any]      # å›¾è®ºæŒ‡æ ‡
    edge_stats: Dict[str, Any]   # æ¯æ¡è¾¹çš„ç»Ÿè®¡ä¿¡æ¯
    cluster_labels: np.ndarray   # (n_all,) è°±èšç±»æ ‡ç­¾

def build_hfo_network(
    group_analysis_npz: str,
    dist_matrix: Optional[np.ndarray] = None,
    # èŠ‚ç‚¹ç­›é€‰ï¼ˆè°±èšç±»å‚æ•°ï¼‰
    min_dist_mm: float = 5.0,
    min_cluster_size: int = 3,
    n_clusters: Optional[int] = None,  # None = Eigengap è‡ªåŠ¨
    alpha: float = 0.65,               # EigenCentrality vs Rate æƒè¡¡
    # éª¨æ¶æ„å»º
    min_coact: float = 0.10,
    # æ–¹å‘åˆ¤å®š
    min_events: int = 5,
    lag_thresh_ms: float = 5.0,
    consistency_thresh: float = 0.6,
    p_value_thresh: float = 0.05,
    # Stability
    stability_window_sec: float = 300.0,
) -> NetworkResult:
    """
    ä¸€ç«™å¼æ„å»ºç™«ç—«ç½‘ç»œï¼ˆPhase A: Channel-Scaleï¼‰ã€‚

    æµç¨‹ï¼šè°±èšç±»èŠ‚ç‚¹é€‰æ‹© â†’ éª¨æ¶æ„å»º â†’ æ–¹å‘æ³¨å…¥ â†’ å¤åˆæƒé‡ â†’ å›¾è®ºæŒ‡æ ‡

    Returns
    -------
    NetworkResult : åŒ…å«æœ‰å‘åŠ æƒé‚»æ¥çŸ©é˜µã€èŠ‚ç‚¹æƒé‡å’Œå›¾è®ºæŒ‡æ ‡
    """
    ...
```

**å¯è§†åŒ–ç»ˆæç›®æ ‡**ï¼š

```python
def plot_outflow_brain_map(
    network_result: NetworkResult,
    mni_coords: np.ndarray,
    output_path: str,
):
    """
    3D è„‘å›¾ï¼ˆPhase B äº¤ä»˜ç‰©ï¼‰ï¼š
    - èŠ‚ç‚¹é¢œè‰² = Net Outflow (çº¢=Source, è“=Sink)
    - èŠ‚ç‚¹å¤§å° = Local Efficiency
    - è¾¹é¢œè‰² = ä¼ æ’­æ–¹å‘
    - è¾¹ç²—ç»† = æƒé‡

    è¿™æ˜¯ç›´æ¥å¯¹è¯ä¸´åºŠåŒ»ç”Ÿçš„"ç»ˆæå›¾è¡¨"ã€‚
    """
    ...

def plot_network_topology_2d(
    network_result: NetworkResult,
    output_path: str,
    layout: str = 'spring',
):
    """
    2D ç½‘ç»œæ‹“æ‰‘å›¾ï¼ˆPhase A äº¤ä»˜ç‰©ï¼‰ï¼š
    - èŠ‚ç‚¹é¢œè‰² = Net Outflow
    - èŠ‚ç‚¹å¤§å° = Node Weight (EigenCentrality Ã— Rate)
    - è¾¹ç²—ç»† = å¤åˆæƒé‡
    - å¸ƒå±€ = spring / circular / spectral

    ä¸éœ€è¦ MNI åæ ‡ï¼ŒPhase A å³å¯ç”Ÿæˆã€‚
    """
    ...
```

---

#### 4.9 åŠŸèƒ½æ¸…å• (Feature Checklist)

**Phase A â€” Channel-Scale MVPï¼ˆç«‹å³å¯åšï¼‰**

| åŠŸèƒ½ | è¯´æ˜ | ä¾èµ– | çŠ¶æ€ |
|------|------|------|------|
| A.1 è°±èšç±»èŠ‚ç‚¹ç­›é€‰ | Eigengap è‡ªé€‚åº” + ç‡è°ƒåˆ¶ä¸­å¿ƒæ€§ | `coact_all_*`, `sklearn` | â¬œ |
| A.2 æ›¿ä»£æ•°æ®æ£€éªŒ | Surrogate test éªŒè¯å…±æ¿€æ´»æ˜¾è‘—æ€§ | `events_bool` | â¬œ |
| A.3 éª¨æ¶æ„å»º | åŠ æƒæ— å‘å›¾ï¼ˆCo-activation é˜ˆå€¼ï¼‰ | `coact_ratio` | â¬œ |
| A.4 æ–¹å‘æ³¨å…¥ | Wilcoxon + ä¸€è‡´æ€§ + é›¶æ»åè¿‡æ»¤ | `lag_raw` | â¬œ |
| A.5 Stability æƒé‡ | æ—¶é—´çª—åˆ‡ç‰‡ + CV è®¡ç®— | `event_windows` | â¬œ |
| A.6 å¤åˆæƒé‡ | Coact Ã— Consistency Ã— Stability | â€” | â¬œ |
| A.7 å›¾è®ºæŒ‡æ ‡ | Net Outflow, Local Efficiency, Betweenness | `networkx` | â¬œ |
| A.8 2D ç½‘ç»œæ‹“æ‰‘å›¾ | Spring/Circular å¸ƒå±€ | `matplotlib` | â¬œ |
| A.9 ä¼ æ’­è·¯å¾„ | æœ€çŸ­è·¯å¾„æ ‘ | `adj` | â¬œ |

**Phase B â€” Channel + Geometryï¼ˆéœ€ MNI åæ ‡ï¼‰**

| åŠŸèƒ½ | è¯´æ˜ | é˜»å¡æ¡ä»¶ | çŠ¶æ€ |
|------|------|----------|------|
| B.1 ç©ºé—´çº¦æŸéª¨æ¶ | è·ç¦»æƒ©ç½š + å®¹ç§¯ä¼ å¯¼å‰”é™¤ | MNI coords | â¬œ |
| B.2 ä¼ æ’­é€Ÿåº¦éªŒè¯ | 0.1-10 m/s ç”Ÿç†èŒƒå›´æ£€æŸ¥ | MNI coords | â¬œ |
| B.3 ç—…ç†åŠ æƒ | FR æ¯”ä¾‹åŠ æƒ | HFO type åˆ†ç±» | â¬œ |
| B.4 3D è„‘å›¾ | Outflow é¢œè‰²æ˜ å°„ | MNI coords | â¬œ |
| B.5 åŠ¨æ€åˆ‡ç‰‡ | Pre-ictal vs Interictal ç½‘ç»œå¯¹æ¯” | Seizure onsets | â¬œ |
| B.6 Sink/Source åè½¬ | $\Delta$Outflow (ictal - interictal) | B.5 | â¬œ |

**Phase C â€” Source Space ç ”ç©¶å‰æ²¿**

| åŠŸèƒ½ | è¯´æ˜ | é˜»å¡æ¡ä»¶ | çŠ¶æ€ |
|------|------|----------|------|
| C.1 å‰å‘æ¨¡å‹(BEM/FEM) | æ‚£è€…ä¸ªæ€§åŒ–å¯¼è”åœº | FreeSurfer + MRI | â¬œ |
| C.2 LFM æ¦‚ç‡æŠ•å½± | çµæ•åº¦åŠ æƒæ˜ å°„ | C.1 | â¬œ |
| C.3 SC-FC è€¦åˆå›¾ | è§£å‰–å…ˆéªŒçº¦æŸ | HCP tractography | â¬œ |
| C.4 PDC/é¢‘è°±æ ¼å…°æ° | é¢‘åŸŸå› æœæ€§ | æ¨¡å‹é˜¶æ•°é€‰æ‹© | â¬œ |
| C.5 NMM éªŒè¯ | åˆ†æ-ç»¼åˆé—­ç¯ | ç‹¬ç«‹ç ”ç©¶è¯¾é¢˜ | â¬œ |

---

#### 4.10 æºç©ºé—´æ„å»ºè¿œæ™¯ (Source Space Vision) â€” Phase C ç†è®ºåŸºç¡€

> æœ¬èŠ‚è®°å½• Source-Scale ç½‘ç»œæ„å»ºçš„ç†è®ºåŸºç¡€å’Œå·¥ç¨‹è·¯å¾„ã€‚**å½“å‰ä¸å®ç°**ï¼Œä½œä¸ºç ”ç©¶å‰æ²¿å‚è€ƒã€‚

##### 4.10.1 ç²’åº¦å›°å¢ƒ (Granularity Dilemma)

| å°ºåº¦ | åˆ†è¾¨ç‡ | å¤±æ•ˆåŸå›  |
|------|--------|---------|
| **è„‘åŒº (AAL/DK)** | ~100 åŒºåŸŸ | HFO ç”Ÿæˆå™¨ <2mmï¼Œè„‘åŒºå¹³å‡åŒ–å½»åº•æ·¹æ²¡ç—…ç†ä¿¡å·ï¼ŒSNR æŒ‡æ•°ä¸‹é™ |
| **é¡¶ç‚¹ (Vertex)** | ~20k/åŠçƒ | SEEG ä»… 100-200 è§¦ç‚¹ â†’ æåº¦æ¬ å®šé€†é—®é¢˜ â†’ æ— æ•°æ®åŒºåŸŸçš„"æ’å€¼å¹»è§‰" |
| **ä¼ æ„Ÿä½“ç§¯ (VOI)** | **5mm åŠå¾„** | âœ… åŒ¹é… SEEG å®ç”µæä¼ æ„ŸåŠå¾„ (~3-5mm)<br>âœ… åŒ…å« HFO å¾®è§‚å‘ç”Ÿç»“æ„<br>âœ… é¿å…è¿‡åº¦æ’å€¼ |

**ç»“è®º**ï¼šæºç©ºé—´èŠ‚ç‚¹åº”å®šä¹‰ä¸ºä»¥ç”µæè§¦ç‚¹ä¸ºä¸­å¿ƒçš„ 5mm VOIï¼ˆVirtual Voxelsï¼‰ï¼Œéå‡åŒ€å…¨è„‘ç½‘æ ¼ã€‚

##### 4.10.2 LFM æ¦‚ç‡æŠ•å½± (Lead-Field Weighted Projection)

> æ— éœ€æ±‚è§£å¤æ‚çš„æºæˆåƒé€†é—®é¢˜ã€‚åˆ©ç”¨å¯¼è”åœºçŸ©é˜µä½œä¸ºå‡ ä½•å…ˆéªŒè¿›è¡Œæ¦‚ç‡æ˜ å°„ã€‚

**æ ¸å¿ƒå…¬å¼**ï¼š

$$W_{ji} = \frac{L_{ij}^2}{\sum_{k \in \text{Channels}} L_{kj}^2}$$

$$\text{SourceMetric}_j = \sum_{i} W_{ji} \cdot \text{ChannelMetric}_i$$

å…¶ä¸­ $L_{ij}$ æ˜¯å¯¼è”åœºçŸ©é˜µä¸­æº $j$ å¯¹é€šé“ $i$ çš„è´¡çŒ®ï¼ˆåŒ…å«è·ç¦»è¡°å‡å’Œå¶æå­æ–¹å‘ä¿¡æ¯ï¼‰ã€‚ä½¿ç”¨å¹³æ–¹æ˜¯å› ä¸ºåŠŸç‡/èƒ½é‡éšè·ç¦»å¹³æ–¹è¡°å‡ã€‚

**ä¼˜åŠ¿**ï¼š
- è®¡ç®—é«˜æ•ˆï¼šä¸€æ¬¡æ€§çº¿æ€§å˜æ¢ï¼Œéè¿­ä»£åæ¼”
- ç‰©ç†åˆç†ï¼šè‡ªåŠ¨å¤„ç†è·ç¦»åŠ æƒ + æ–¹å‘æ€§
- é¿å… Double Countingï¼šå½’ä¸€åŒ–æƒé‡è‡ªç„¶åˆ†é…é‡å åŒºåŸŸ

**å¯¹å…±æ¿€æ´»çŸ©é˜µçš„æ˜ å°„æ‰©å±•**ï¼š

$$\text{SourceCoAct}_{jk} = \sum_{m,n} W_{jm} \cdot \text{ChannelCoAct}_{mn} \cdot W_{kn}$$

##### 4.10.3 SC-FC è€¦åˆå›¾ (Structure-Function Coupled Graph)

> åœ¨æºç©ºé—´å®šä¹‰ä¼ æ’­è·¯å¾„æ—¶ï¼Œå¿…é¡»å¼•å…¥ HCP SC ä½œä¸ºè´å¶æ–¯å…ˆéªŒã€‚

$$P(E_{A \to B} | \text{Data}) \propto \text{FC}_{A \to B} \times \text{SC}_{A \to B}$$

**ç‰©ç†æ„ä¹‰**ï¼šå¦‚æœæº A åˆ°æº B çš„åŠŸèƒ½è¿æ¥ï¼ˆFCï¼‰å¾ˆå¼ºï¼Œä½†æ— ç™½è´¨çº¤ç»´æŸç›´æ¥è¿æ¥ï¼ˆSC â‰ˆ 0ï¼‰ï¼Œåˆ™è¯¥"è¿æ¥"æå¯èƒ½æ˜¯é—´æ¥çš„æˆ–è™šå‡çš„ã€‚

**å·¥ç¨‹ä¾èµ–é“¾**ï¼š
1. FreeSurfer çš®å±‚é‡å»º â†’ é«˜åˆ†è¾¨ç‡ mesh
2. BEM/FEM å‰å‘å»ºæ¨¡ â†’ å¯¼è”åœºçŸ©é˜µ $G$
3. ç”µæå®šä½ (LeadDBS/iElectrodes) â†’ MNI åæ ‡
4. HCP tractography â†’ ç»“æ„è¿æ¥çŸ©é˜µ SC
5. LFM æ¦‚ç‡æŠ•å½± â†’ æºç©ºé—´æŒ‡æ ‡
6. SC Ã— FC â†’ è€¦åˆå›¾

**ç°å®è¯„ä¼°**ï¼šè¿™æ˜¯ä¸€æ¡ 6 ä¸ªæœˆçš„å·¥ç¨‹è·¯å¾„ï¼Œæ¯ä¸ªç¯èŠ‚éƒ½éœ€è¦ç‹¬ç«‹éªŒè¯ã€‚ä½†ä¸€æ—¦å»ºæˆï¼Œå¯ä»¥å®ç°ä»ç”µç”Ÿç†åˆ°è§£å‰–çš„æ— ç¼å¯¹æ¥ï¼Œè¿™æ˜¯æœ€ç»ˆçš„ä¸´åºŠè½¬åŒ–ç›®æ ‡ã€‚

---

### æ¨¡å—5: src/visualization.py âœ… é‡æ„å®Œæˆï¼ˆ2026-01-16ï¼‰

> **é“å¾‹**ï¼švisualization åªè´Ÿè´£è¯»å–å·²è®¡ç®—çš„ä¸­é—´ç»“æœå¹¶ç”»å›¾ï¼Œ**ä¸åšä»»ä½•å¤æ‚è®¡ç®—**ã€‚

#### èŒè´£è¾¹ç•Œ

**âœ… å…è®¸**:
1. è¯»å– `*_groupAnalysis.npz` æˆ– `*_envCache.npz`
2. æ ¹æ®å‚æ•°é€‰æ‹©å­é›†ï¼ˆé€šé“ã€äº‹ä»¶ï¼‰
3. è°ƒç”¨ matplotlib ç”»å›¾
4. ç®€å•çš„æ•°æ®åˆ‡ç‰‡ã€reshapeã€é¢œè‰²æ˜ å°„

**âŒ ç¦æ­¢**:
- è®¡ç®— STFT
- è®¡ç®—è´¨å¿ƒ
- è®¡ç®— Hilbert envelope
- ä»»ä½•è¶…è¿‡ 50 è¡Œçš„æ•°æ®å¤„ç†é€»è¾‘

---

#### åŠŸèƒ½æ€»è§ˆï¼šå¯è§†åŒ–äº§å‡ºä¸èµ„æºä¾èµ–

**A. åŸºç¡€å¯è§†åŒ–ï¼ˆæ•°æ®æ¢ç´¢ï¼‰**

| å‡½æ•° | äº§å‡ºå›¾è¡¨ | å¿…éœ€èµ„æº | ç”¨é€” |
|------|---------|---------|------|
| `plot_seeg_segment` | å¤šé€šé“æ—¶åºæ³¢å½¢ | `PreprocessingResult` (å†…å­˜å¯¹è±¡) | æŸ¥çœ‹é¢„å¤„ç†åæ•°æ® |
| `plot_from_result` | å¿«é€Ÿæ³¢å½¢å›¾ | `PreprocessingResult` | ä¾¿æ·å°è£… |
| `plot_shaft_channels` | å•ç”µæä¸²æ³¢å½¢ | `PreprocessingResult` | å®šä½å¼‚å¸¸ç”µæ |
| `plot_preprocessing_comparison` | å‰åå¯¹æ¯”å›¾ | 2ä¸ª `PreprocessingResult` | éªŒè¯é¢„å¤„ç†æ•ˆæœ |
| `plot_raw_filtered_envelope` | Raw/æ»¤æ³¢/åŒ…ç»œä¸‰è”å›¾ | `PreprocessingResult` + é€šé“é€‰æ‹© | æ£€æµ‹å™¨è°ƒè¯• |
| `plot_event_counts` | HFOäº‹ä»¶è®¡æ•°æŸ±çŠ¶å›¾ | `HFODetectionResult` | å¿«é€Ÿä¼ªè¿¹ç­›æŸ¥ |

**B. è®ºæ–‡çº§å¯è§†åŒ–ï¼ˆåªè¯»å–ä¸­é—´ç»“æœï¼‰**

| å‡½æ•° | äº§å‡ºå›¾è¡¨ | å¿…éœ€èµ„æº | å¯é€‰èµ„æº | ç”¨é€” |
|------|---------|---------|---------|------|
| `plot_paper_fig1_bandpassed_traces` | **Fig1**: æ‹¼æ¥äº‹ä»¶çª—å£çš„å¸¦é€šæ³¢å½¢ raster | `*_envCache.npz`<br>`*_packedTimes.npy` | - | å±•ç¤ºç¾¤ä½“äº‹ä»¶æ—¶åºç‰¹å¾ |
| `plot_group_event_tf_propagation_from_cache` | **Fig2**: å¤šé€šé“TFä¼ æ’­å›¾ï¼ˆé‡‘æ ‡å‡†ï¼‰ | `*_groupTF_tiles.npz`<br>`*_groupAnalysis.npz` | - | å±•ç¤ºç¾¤ä½“äº‹ä»¶TFåŸŸä¼ æ’­æ¨¡å¼ |
| `plot_lag_heatmaps_from_group_analysis` | **3å¼ çƒ­å›¾**: Energy/Rank/Lag (channelsÃ—events) | `*_groupAnalysis.npz`<br>`*_envCache.npz`<br>`*_packedTimes.npy` | - | é‡åŒ–ä¼ æ’­æ»åå’Œèƒ½é‡åˆ†å¸ƒ |
| `plot_lag_statistics` | **ç»Ÿè®¡ä¸‰è”å›¾**: Lagåˆ†å¸ƒ/Rankåˆ†å¸ƒ/é€šé“å‚ä¸ç‡ | `*_groupAnalysis.npz` | - | ç¾¤ä½“ç»Ÿè®¡ç‰¹å¾ |
| `plot_tf_centroid_statistics` | **TFè´¨å¿ƒç»Ÿè®¡**: é¢‘ç‡è´¨å¿ƒ/æ—¶é—´è´¨å¿ƒåˆ†å¸ƒ | `*_groupAnalysis.npz` | - | TFè´¨å¿ƒç‰¹å¾åˆ†æ |

**C. åº•å±‚å·¥å…·å‡½æ•°**

| å‡½æ•° | äº§å‡º | è¾“å…¥ | è¯´æ˜ |
|------|------|------|------|
| `detections_to_events` | äº‹ä»¶å­—å…¸åˆ—è¡¨ | `HFODetectionResult` | æ ¼å¼è½¬æ¢ï¼Œä¾› `plot_seeg_segment` å åŠ  |
| `plot_lag_heatmaps` | 3å¼ çƒ­å›¾ | numpy æ•°ç»„ | åº•å±‚ç»˜å›¾å‡½æ•°ï¼Œé€šå¸¸ç”¨é«˜å±‚å°è£… |

---

#### æ ¸å¿ƒèµ„æºæ–‡ä»¶é€ŸæŸ¥

**ä¸­é—´ç»“æœæ–‡ä»¶ï¼ˆå¿…éœ€ï¼‰**ï¼š

```python
# 1. Envelope + Bandpass ç¼“å­˜
"<record>_envCache_<band>_<ref>.npz"
â”œâ”€ env: (n_ch, n_samples) Hilbert envelope
â”œâ”€ x_band: (n_ch, n_samples) bandpassed signalï¼ˆå¯é€‰ï¼‰
â”œâ”€ sfreq: é‡‡æ ·ç‡
â””â”€ ch_names: é€šé“ååˆ—è¡¨

# 2. å®Œæ•´åˆ†æç»“æœ
"<record>_groupAnalysis.npz"
â”œâ”€ centroid_time: (n_ch, n_events) æ—¶é—´è´¨å¿ƒ
â”œâ”€ tf_centroid_time: (n_ch, n_events) TF 2Dè´¨å¿ƒ-æ—¶é—´åˆ†é‡ï¼ˆå¯é€‰ï¼‰
â”œâ”€ tf_centroid_freq: (n_ch, n_events) TF 2Dè´¨å¿ƒ-é¢‘ç‡åˆ†é‡ï¼ˆå¯é€‰ï¼‰
â”œâ”€ lag_raw: (n_ch, n_events) ç›¸å¯¹æ»å(ç§’)
â”œâ”€ lag_rank: (n_ch, n_events) æ’å(0=æœ€æ—©)
â”œâ”€ coact_event_count: (n_ch, n_ch) å…±åŒæ¿€æ´»äº‹ä»¶æ•°
â”œâ”€ coact_event_ratio: (n_ch, n_ch) å…±åŒæ¿€æ´»æ¯”ä¾‹
â”œâ”€ coact_time_ratio: (n_ch, n_ch) è´¨å¿ƒç»å¯¹æ—¶é—´å¯¹é½å¼ºåº¦
â”œâ”€ coact_rank_ratio: (n_ch, n_ch) è´¨å¿ƒç›¸å¯¹rankå¯¹é½å¼ºåº¦
â”œâ”€ events_bool: (n_ch, n_events) å‚ä¸mask
â””â”€ sfreq, band, ch_names, event_windows...

# 3. äº‹ä»¶çª—å£
"<record>_packedTimes.npy"
â””â”€ (n_events, 2) [start, end] ç§’

# 4. ç¾¤ä½“TFè°±å›¾ç¼“å­˜ï¼ˆFig2ï¼‰
"<record>_groupTF_tiles.npz"
â”œâ”€ power_db: (n_ch, n_events, n_freqs, n_time) 4D TF tiles (dB)
â”œâ”€ freqs_hz: (n_freqs,) å¯¹æ•°é¢‘ç‡è½´
â”œâ”€ event_indices: (n_events,) å¯¹åº”äº‹ä»¶ç´¢å¼•
â”œâ”€ channel_names: (n_ch,) é€šé“åˆ—è¡¨
â”œâ”€ window_sec: float äº‹ä»¶çª—å£é•¿åº¦
â””â”€ sfreq: float é‡‡æ ·ç‡

# 5. GPUæ£€æµ‹ç»“æœï¼ˆå¯é€‰ï¼Œç”¨äºmaskï¼‰
"<record>_gpu.npz"
â”œâ”€ whole_dets: List[(n_det, 2)] per channel
â””â”€ chns_names: é€šé“å
```

**å…¸å‹å¯è§†åŒ–æµç¨‹**ï¼š

```python
# Step 1: ç”Ÿæˆä¸­é—´ç»“æœï¼ˆä¸€æ¬¡æ€§ï¼‰
from src.group_event_analysis import compute_and_save_group_analysis
out_paths = compute_and_save_group_analysis(
    edf_path='FC10477Q.edf',
    output_dir='./output',
    output_prefix='FC10477Q',
    packed_times_path='FC10477Q_packedTimes.npy',
    gpu_npz_path='FC10477Q_gpu.npz',  # å¯é€‰
    band='ripple',
    reference='bipolar',
    save_env_cache=True,
)

# Step 2: å¯è§†åŒ–ï¼ˆä»»æ„å¤šæ¬¡ï¼Œåªè¯»å–ï¼‰
from src.visualization import (
    plot_paper_fig1_bandpassed_traces,
    plot_group_event_tf_spectrogram_from_cache,
    plot_lag_heatmaps_from_group_analysis,
    plot_lag_statistics,
    plot_tf_centroid_statistics,
)

# Fig1: æ³¢å½¢ raster
fig1 = plot_paper_fig1_bandpassed_traces(
    cache_npz_path=out_paths['env_cache_path'],
    packed_times_path='FC10477Q_packedTimes.npy',
    channel_order=CORE_CHANNELS,
    event_indices=list(range(30)),
)

# Fig2: å¤šé€šé“TFä¼ æ’­ï¼ˆé‡‘æ ‡å‡†ï¼‰
fig2 = plot_group_event_tf_propagation_from_cache(
    tfr_tile_cache_npz_path=out_paths['group_tf_tile_cache_path'],
    group_analysis_npz_path=out_paths['group_analysis_path'],
    channel_order=CORE_CHANNELS,
    event_indices=list(range(30)),
    plot_window_sec=0.1,  # 100ms æ—¶é—´çª—å£
    low_color="#1f4b99",  # è“è‰²èƒŒæ™¯
    low_color_percentile=70.0,  # ä½äº70%è®¾ä¸ºèƒŒæ™¯
    cmap="Reds",  # çº¢è‰²èƒ½é‡æ˜ å°„
)

# çƒ­å›¾: Energy/Rank/Lag
figE, figR, figL = plot_lag_heatmaps_from_group_analysis(
    group_analysis_npz=out_paths['group_analysis_path'],
    env_cache_npz=out_paths['env_cache_path'],
    packed_times_npy='FC10477Q_packedTimes.npy',
    channel_names=CORE_CHANNELS,
    max_events=100,
)

# ç»Ÿè®¡å›¾
fig_stats = plot_lag_statistics(
    group_analysis_npz=out_paths['group_analysis_path'],
    patient_id='chengshuai',
    record_id='FC10477Q',
)

# TFè´¨å¿ƒç»Ÿè®¡
fig_tf = plot_tf_centroid_statistics(
    group_analysis_npz=out_paths['group_analysis_path'],
)
```

---

#### é‡æ„æ€»ç»“ï¼ˆ2026-01-16ï¼‰

âœ… **å®Œæˆçš„é‡æ„**ï¼š
1. âœ… å°† TF è´¨å¿ƒè®¡ç®—ä» `visualization.py` è¿ç§»åˆ° `group_event_analysis.py`
2. âœ… æ·»åŠ  `compute_tf_centroids()` è®¡ç®— 2D TF è´¨å¿ƒï¼ˆæ—¶é—´+é¢‘ç‡ï¼‰
3. âœ… `*_groupAnalysis.npz` ç°åœ¨åŒ…å« `tf_centroid_time` å’Œ `tf_centroid_freq`
4. âœ… `plot_paper_fig2_*` é‡æ„ä¸ºè¯»å–é¢„è®¡ç®—è´¨å¿ƒï¼Œä¸å†å†…éƒ¨è®¡ç®— STFT
5. âœ… æ–°å¢ä¾¿åˆ©å‡½æ•°ï¼š
   - `plot_lag_heatmaps_from_group_analysis()` - ä¸€é”®è¯»å–+ç»˜åˆ¶çƒ­å›¾
   - `plot_lag_statistics()` - ç»Ÿè®¡åˆ†æä¸‰è”å›¾
   - `plot_tf_centroid_statistics()` - TFè´¨å¿ƒåˆ†å¸ƒç»Ÿè®¡
6. âœ… `chengshuai_hfo_analysis.ipynb` é‡æ„ä¸ºçº¯å¯è§†åŒ–ç»ˆç«¯ï¼ˆä¸åšè®¡ç®—ï¼‰

**æ¶æ„éªŒè¯**ï¼š
- âœ… visualization.py ä¸å†æœ‰ä»»ä½• STFT/è´¨å¿ƒè®¡ç®—é€»è¾‘
- âœ… æ‰€æœ‰å¤æ‚è®¡ç®—åœ¨ `group_event_analysis.py`
- âœ… notebook åªè°ƒç”¨ visualization å‡½æ•°ï¼Œä¸å†™å†…è”ç»˜å›¾ä»£ç 
- âœ… ä¸­é—´ç»“æœå¯å¤ç”¨ï¼Œé¿å…é‡å¤è®¡ç®—

**å…³é”®æŠ€æœ¯å†³ç­–**:
- **æ³¢å½¢é¢œè‰²**: `tableau_20_no_red` é¿å…ä¸HFOçº¢è‰²æ ‡è®°å†²çª
- **äº‹ä»¶æ ‡æ³¨**: é»˜è®¤ `style='tick'` ç»†çº¿ï¼Œä¸é®æŒ¡æ³¢å½¢
- **TFè´¨å¿ƒ**: ä½¿ç”¨ wavelet TFR + åŠ¨æ€åŸºçº¿logæ ¡æ­£ï¼Œå†åœ¨è¯¥TFå›¾ä¸Šè®¡ç®—2Dè´¨å¿ƒ

---

## 5. å¿«é€Ÿå¼€å‘å‚è€ƒ

### 5.1 preprocessing.py å¿«é€Ÿä¸Šæ‰‹

```python
from src.preprocessing import SEEGPreprocessor

# æ ‡å‡†ç”¨æ³•ï¼ˆè‡ªåŠ¨é€‰æ‹©é‡‡æ ·ç‡ï¼‰
preprocessor = SEEGPreprocessor(
    target_band='ripple',        # 'ripple' (1000Hz) or 'fast_ripple' (2000Hz)
    reference='bipolar',         # 'bipolar' / 'car' / 'none'
    use_gpu=True,                # è‡ªåŠ¨é™çº§åˆ° CPU å¦‚æœæ—  GPU
)
result = preprocessor.run('path/to/file.edf')

# å¤ç° GPU é€šé“åˆ—è¡¨ï¼ˆæ˜¾å¼ï¼‰
gpu_data = np.load('FC10477Q_gpu.npz', allow_pickle=True)
gpu_channels = [str(ch) for ch in gpu_data['chns_names']]

preprocessor = SEEGPreprocessor(
    reference='bipolar',
    include_channels=gpu_channels,  # æ˜¾å¼é€šé“ç™½åå•
)

# æ’é™¤åé€šé“ï¼ˆæ˜¾å¼ï¼‰
preprocessor = SEEGPreprocessor(
    reference='bipolar',
    exclude_channels=['A1-A2', 'EMG1-EMG2'],  # æ˜¾å¼é»‘åå•
)

# æ·»åŠ è‡ªå®šä¹‰ FilterBackendï¼ˆé«˜çº§ï¼‰
from src.preprocessing import FilterBackend

class MyCustomBackend(FilterBackend):
    def apply_notch(self, data, sfreq, freqs):
        # ä½ çš„å®ç°
        return data
    
    def apply_bandpass(self, data, sfreq, low, high):
        # ä½ çš„å®ç°
        return data

preprocessor = SEEGPreprocessor()
preprocessor.filter_backend = MyCustomBackend()
```

### 5.2 å¸¸è§ä»»åŠ¡é€ŸæŸ¥

| ä»»åŠ¡ | ä»£ç  |
|------|------|
| **é¢„å¤„ç† + HFOæ£€æµ‹** | `preprocessor.run(edf) -> detector.detect(result.data, result.sfreq)` |
| **å®Œæ•´åˆ†ææµç¨‹** | `compute_and_save_group_analysis(edf_path, ...)` |
| **å¯è§†åŒ–è®ºæ–‡å›¾** | `plot_paper_fig1_bandpassed_traces(env_cache_npz, ...)` |
| **è¯»å–ä¸­é—´ç»“æœ** | `load_group_analysis_results('*_groupAnalysis.npz')` |
| **Envelope ç¼“å­˜** | `precompute_envelope_cache(data, sfreq, ch_names, ...)` |

### 5.3 æœªæ¥é‡æ„è®¡åˆ’ï¼ˆå¯é€‰ï¼Œä½ä¼˜å…ˆçº§ï¼‰

**Phase 2: èŒè´£åˆ†ç¦»ï¼ˆLoader/Processorï¼‰**
- ç›®æ ‡ï¼šæ‹†åˆ† EDF åŠ è½½å’Œæ•°æ®å˜æ¢é€»è¾‘
- æ”¶ç›Šï¼šæ”¯æŒå¤šç§æ•°æ®æ ¼å¼ï¼ˆBrainVision, Neuralynx, ...ï¼‰
- è§¦å‘æ¡ä»¶ï¼šéœ€è¦æ”¯æŒ â‰¥3 ç§æ•°æ®æ ¼å¼æ—¶

**Phase 3: ç§»åŠ¨ seizure detection**
- ç›®æ ‡ï¼š`detect_seizure_onsets_from_data()` â†’ `src/seizure_detection.py`
- æ”¶ç›Šï¼šæ¨¡å—èŒè´£æ›´æ¸…æ™°ï¼ˆpreprocessing ä¸åº”åŒ…å«åˆ†æé€»è¾‘ï¼‰
- è§¦å‘æ¡ä»¶ï¼šéœ€è¦æ‰©å±•å¤šç§å‘ä½œæ£€æµ‹ç®—æ³•æ—¶

## 6. å…³é”®æŠ€æœ¯é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ

| é™·é˜± | é—®é¢˜æè¿° | è§£å†³æ–¹æ¡ˆ |
|------|----------|----------|
| "Pre-bipolaræ¨æ–­" | é€šè¿‡"æœ«ç«¯contactç¼ºå¤±"æ¨æ–­EDFå·²bipolar â†’ **è¯¯è§£** | **ç¦æ­¢æ¨æ–­**ï¼›éœ€è¦ä»€ä¹ˆå°±æ˜¾å¼ `reference='bipolar'/'car'/'none'` |
| Bipolaræ–­æ¡¥ | è·¨ç”µæä¸²å·®åˆ†äº§ç”Ÿä¼ªä¿¡å· | ä¸¥æ ¼è§£æç”µæå‰ç¼€, ä»…åŒä¸²ç›¸é‚» |
| FRé‡‡æ ·ç‡ | 1000Hzä¸‹500Hzä¸¥é‡è¡°å‡ | FRåˆ†æä¿ç•™2000Hz |
| Ictalé˜ˆå€¼ | å‘ä½œæœŸæ‹‰é«˜å…¨å±€é˜ˆå€¼ | å‰”é™¤Ictalåè®¡ç®—åŸºçº¿ |
| é¸¡ç”Ÿè›‹é—®é¢˜ | HFOç°‡è¢«è¯¯åˆ¤ä¸ºIctal | æŒç»­æ—¶é—´çº¦æŸ >3ç§’ |
| ç›¸ä½æ»‘ç§» | XCorr cycle skipping | å¯¹**HilbertåŒ…ç»œ**åšäº’ç›¸å…³ |
| æ ¸å¿ƒé€šé“å¾ªç¯è®ºè¯ | é«˜å¯†åº¦â‰ Source | å¤šç­–ç•¥å¯¹æ¯”ç­›é€‰ |
| å›¾éè¿é€š | Eccentricityè®¡ç®—å¤±æ•ˆ | Harmonic Centralityæ›¿ä»£ |
| é›¶æ»åç¦»æ•£åŒ– | è¿‘è·å¿«é€Ÿä¼ æ’­è¢«è¯¯æ€ | è·ç¦»æ¡ä»¶å‰”é™¤ (ä»…è¿œè·lag=0) |
| **GPUä¸å¯ç”¨** | æœåŠ¡å™¨æœ‰GPUæœ¬åœ°æ—  | æ‰€æœ‰ç®—æ³•CPU/GPUåŒç‰ˆæœ¬, è‡ªåŠ¨é™çº§ |

---

## 7. å¼€å‘è¿›åº¦

- [x] é¡¹ç›®ç»“æ„è®¾è®¡
- [x] å¼€å‘è®¡åˆ’æ–‡æ¡£
- [x] **æ¨¡å—1: preprocessing.py** âœ… Phase 1 é‡æ„å®Œæˆ (2026-01-30)
  - [x] ç”µæåç§°è§£æ (ElectrodeParser)
  - [x] é‡å‚è€ƒï¼ˆæ˜¾å¼ï¼‰:
    - [x] Bipolar (BipolarReferencer) â€” å‘½å `A1-A2`
    - [x] CAR per shaft (CommonAverageReferencer)
    - [x] Noneï¼ˆä¿æŒåŸå§‹EDFï¼‰
  - [x] é€šé“é€‰æ‹©ï¼ˆæ˜¾å¼ï¼‰: include/exclude channelsï¼ˆç”¨äºåŒ¹é…GPUé€šé“åˆ—è¡¨ï¼‰
  - [x] é‡é‡‡æ · + Notchæ»¤æ³¢
  - [x] **âœ… FilterBackend æ¶æ„é‡æ„** - æ¶ˆé™¤æ‰€æœ‰ GPU if/else åˆ†æ”¯
  - [x] **âœ… åˆ é™¤åºŸä»£ç ** - PreBipolarDetector, validate_against_gpu_results, exclude_last_n
  - [x] GPUåŠ é€Ÿæ”¯æŒ (CuPyå¯é€‰)
  - [x] é€šé“è´¨é‡æ£€æŸ¥
  - [x] chengshuai/FC10477Q: EDF vs GPU é€šé“å·®å¼‚æ¥æºç¡®è®¤ï¼ˆGPU=æ˜¾å¼é€šé“å­é›†ï¼›ä¸ç”¨äºæ¨æ–­é‡å‚è€ƒï¼‰
- [x] **æ¨¡å—2: hfo_detector.py** âœ… Phase 2 é‡æ„å®Œæˆï¼ˆ2026-01-31ï¼‰
  - [x] åˆ é™¤ `mad_hysteresis` ç®—æ³•ï¼ˆ-200è¡Œï¼‰
  - [x] å°è£… `BQKDetector` ç±»ï¼ˆé¢„è®¡ç®—æ»¤æ³¢å™¨ç³»æ•°ï¼‰
  - [x] å®ç° joblib å¹¶è¡ŒåŒ–ï¼ˆå¤šå¸¦åŒ…ç»œè®¡ç®—ï¼‰
  - [x] æ€§èƒ½æµ‹è¯•ï¼šä¸²è¡Œ vs å¹¶è¡Œï¼ˆå‘ç°å°æ•°æ®å¹¶è¡Œåè€Œæ…¢ï¼‰
  - [x] åŒé˜ˆå€¼æ£€æµ‹ï¼ˆrel_thresh Ã— local_median âˆ§ abs_thresh Ã— global_medianï¼‰
  - [x] äº‹ä»¶åˆå¹¶ç­›é€‰ï¼ˆmin_gap + min_lastï¼‰
  - [x] Ripple/FRåˆ†ç¦»
  - [x] Chunkedå¤„ç†ï¼ˆ30s chunk + 1s overlapï¼‰
  - [x] æ•°å€¼éªŒè¯ï¼šä¸åŸ `bqk_utils.py` è¯¯å·® <1e-9
- [x] **æ¨¡å—3: group_event_analysis.py** âœ… 2026-01-16ï¼ˆæ ¸å¿ƒé€»è¾‘å®Œæˆï¼‰
  - [x] çª—å£æ„å»º (build_windows_from_detections)
  - [x] Envelopeç¼“å­˜ (precompute_envelope_cache)
  - [x] è´¨å¿ƒè®¡ç®— (compute_centroid_matrix_from_envelope_cache)
  - [x] Lag/Rankè®¡ç®— (lag_rank_from_centroids)
  - [x] é€šé“ç­›é€‰ (select_core_channels_by_event_count)
  - [x] éªŒè¯å‡½æ•° (validate_* ç³»åˆ—)
  - [x] TFè´¨å¿ƒè®¡ç®— (compute_tf_centroids) âœ…
  - [x] ç»Ÿä¸€ç»“æœå­˜å‚¨ (save_group_analysis_results) âœ…
  - [x] ä¸€é”®API (compute_and_save_group_analysis) âœ…
- [x] **æ¨¡å—5: visualization.py** âœ… 2026-01-16ï¼ˆé‡æ„å®Œæˆï¼‰
  - [x] åŸºç¡€å¯è§†åŒ–ï¼ˆæ³¢å½¢ã€äº‹ä»¶æ ‡æ³¨ã€è°ƒè¯•è§†å›¾ï¼‰
  - [x] Fig1: å¸¦é€šæ³¢å½¢ rasterï¼ˆè¯»å– envCacheï¼‰
  - [x] Fig2: TFåŠŸç‡+è´¨å¿ƒè·¯å¾„ï¼ˆè¯»å– groupAnalysis é¢„è®¡ç®—è´¨å¿ƒï¼‰
  - [x] çƒ­å›¾ï¼šEnergy/Rank/Lagï¼ˆè¯»å– groupAnalysisï¼‰
  - [x] ç»Ÿè®¡åˆ†æï¼šLag/Rank/Participationï¼ˆè¯»å– groupAnalysisï¼‰
  - [x] TFè´¨å¿ƒç»Ÿè®¡ï¼ˆè¯»å– groupAnalysisï¼‰
  - [x] âœ… æ¶æ„é‡æ„ï¼šå‰¥ç¦»æ‰€æœ‰ STFT/è´¨å¿ƒè®¡ç®—åˆ° group_event_analysis
  - [ ] ä¼ æ’­åŠ¨å›¾ï¼ˆ500msçª—å£å†…èƒ½é‡ä¼ æ’­åŠ¨ç”»ï¼‰
  - [ ] ç½‘ç»œæ‹“æ‰‘å›¾ï¼ˆå¾…æ¨¡å—4ï¼‰
- [ ] **æ¨¡å—4: network_analysis.py** (ä¸‰é˜¶æ®µé€’è¿›)
  - [ ] **Phase A: Channel-Scale MVP**
    - [ ] A.1 è°±èšç±»èŠ‚ç‚¹ç­›é€‰ (Eigengap + ç‡è°ƒåˆ¶ä¸­å¿ƒæ€§)
    - [ ] A.2 æ›¿ä»£æ•°æ®æ˜¾è‘—æ€§æ£€éªŒ
    - [ ] A.3-A.4 éª¨æ¶æ„å»º + æ–¹å‘æ³¨å…¥ (Wilcoxon + ä¸€è‡´æ€§)
    - [ ] A.5-A.6 Stability æƒé‡ + å¤åˆæƒé‡
    - [ ] A.7 å›¾è®ºæŒ‡æ ‡ (Net Outflow, Local Efficiency, Betweenness)
    - [ ] A.8-A.9 2D ç½‘ç»œæ‹“æ‰‘å›¾ + ä¼ æ’­è·¯å¾„
  - [ ] **Phase B: Channel + Geometry** (é˜»å¡äº MNI åæ ‡)
    - [ ] B.0 ç”µæåæ ‡è·å–
    - [ ] B.1-B.3 ç©ºé—´çº¦æŸ + å®¹ç§¯ä¼ å¯¼å‰”é™¤ + ä¼ æ’­é€Ÿåº¦éªŒè¯
    - [ ] B.4 ç—…ç†åŠ æƒ (FR åˆ†ç±»)
    - [ ] B.5-B.6 3D è„‘å›¾ + Ictal vs Interictal å¯¹æ¯”
  - [ ] **Phase C: Source Space** (ç ”ç©¶å‰æ²¿)
- [x] Notebook: chengshuai_hfo_analysis.ipynb âœ…
- [x] 2026-02-01: toy timelag + env cache æ¥å£æµ‹è¯•ï¼ˆcuda_envï¼‰
- [ ] éªŒè¯ä¸åŸç»“æœä¸€è‡´æ€§
- [ ] å®Œæ•´Pipelineæµ‹è¯•

---

## 8. æµ‹è¯•æ•°æ®

**ç¤ºä¾‹æ‚£è€…**: chengshuai  
**ç¤ºä¾‹è®°å½•**: FC10477Q  
**æ•°æ®è·¯å¾„**: `/mnt/yuquan_data/yuquan_24h_edf/chengshuai/FC10477Q.edf`

**é¢„æœŸè¾“å‡º**:
- Bipolaré€šé“æ•°: ~130ï¼ˆå–å†³äºæ¯æ ¹ç”µæä¸²contactæ•°é‡ä¸ç¼ºå¤±æƒ…å†µï¼‰
- GPUæ£€æµ‹äº‹ä»¶æ•°: 46,738
- æ ¸å¿ƒé€šé“: ['E11', 'K3', 'K5', 'K6', 'K7', 'K8', 'K9', 'K10']
- å¯¹é½äº‹ä»¶æ•°: 2,601

**NotebookéªŒè¯ç»“æœï¼ˆ100s cropï¼‰**:
- Detections: 10232 total
- Top channels: ['K15-K16', 'G13-G14', 'J9-J10', 'K6-K7', 'D13-D14', ...]
